[{"title":"A descriptive framework for the field of deep learning applications in medical images","date":"2022-06-08T16:00:00.000Z","url":"/2022/06/09/DeepLearningMedical/","tags":[["Deep_Learning","/tags/Deep-Learning/"]],"categories":[["Artificial Intelligence","/categories/Artificial-Intelligence/"]],"content":" How to define the â€œdescriptive frameworkâ€? The work of this paper shows comprehensive analysis of historical papers, but this work is still a little confusing to me, why it could be called framework? It is noticed that GAN is also used in the medical images analsis. Actually, in the medical industry, personal health senario is quite complex. Is it meaningful trying to train generative data by algorithm before we really understand the actual medical situation? 0.1 Deep Learning Supervised Learning Weakly Supervised Learning Unsupervised learning Supervised Learning Supervised learning represents a learning method that uses data with manual annotation labels to train the network. For classification,image-level or patch-level labels are required. . In the supervised setting, given datasets D = {(x1, y1), (x2, y2), . . . , (xN , yN )}, the corresponding loss aims to minimize the distance between the predicted value yâ€² and the ground truth y, as Eq. (1). Weakly Supervised Learning Weakly supervised learning mainly consists of incomplete su\u0002pervision, inexact supervision and inaccurate supervision [104], where incomplete supervision is more common in the medical field. The datasets in incomplete supervision can be denoted as D = {(x1, y1), (x2, y2), . . . , (xl, yl), xl+1, . . . , xN }, where only a small subset of labeled data is available. Unsupervised learning Unsupervised learning attempts to train a model with unlabeled data. The Generative unsupervised model is represented by Autoencoder (AE), Sparse Autoencoder (SAE) and Generative Adversarial Network (GAN), which focuses on pixel-level reconstruction error. However, pixel-level generation is computationally expensive. Recently,self-supervised learning (SSL) has become more and more popular. Contrastive learning (CL) is a type of SSL, which has achieved great progress in computer vision, natural language processing and other fields. It hopes to distinguish different inputs in the feature space. The loss function is shown in formula (2) [108], aiming to measure the similarity between two features. 0.2 Convolutional neural network Classification architectures Object detection architectures Segmentation architectures At present, the Convolutional Neural Network (CNN) is the most popular deep neural network for computer vision. The original deep network architecture used for image classification, object detection and segmentation was born based on CNN in supervised learning scenarios. Almost all representative articles are based on CNN. The convolution layer consists of several convolution kernels (filters) and each can be expressed as a linear function in Eq. Classification Architecture For the classification task, there is only one object of a single category in an image/patch. The main process of classification is to feed images into a deep learning model, where the image-level/patch-level labels are required, and finally output the category or its corresponding probability of this image. Object detection architectures Medical image detection is an object detection task in deep learning, where there are multiple objects and categories in one image. Besides classifying images, the typic feature of object detection is locating the position or coordinates of an object with a bounding box. Segmentation architectures Deep learning-based segmentation can be divided into ordinary segmentation, semantic segmentation, and instance segmentation. In the medical field, semantic segmentation is the most common. Compared with image classification and object detection, segmentation is more accurate and more complicated. It outputs pixel-level labels instead of image-level labels. Besides the bounding box, it can also output the exact boundary of the object (Fig. 7). 0.3 Recurrent neural network Recurrent Neural Network (RNN) is a neural network designed to process sequence data. Finally, the output layer is only activated based on the hiddenstate of the last layer, that is, the lth layer, which can be shownin Eq. (7). 0.4 Generative adversarial network Generative Adversarial Network (GAN) introduced by Good fellow et al. [119] is one of the most common architectures in unsupervised learning. It consists of a generator (G) and a discriminator (D). The two of them are playing against each other. The G is used to capture the distribution of the input samples and generate fake images from noise prior as close as possible to the real images, so as to deceive the D. In contrast, the D needs to distinguish whether the sample comes from real data or generated data as much as possible. The value function V(D, G) is shown in Eq. (6). $$V(G,D) =\\mathop{min}\\limits_{G}\\enspace\\mathop{max}\\limits_{D} \\mathbb{E}{x\\sim p_data}(x)[logD(x)]+\\mathbb{E}{z\\sim p_z}(z)[log(1-D(G(z)))]$$ 0.1 Applications of classification Pathologic image X-ray OCT and fundus image Endoscopic image Dermoscopic image EEG / ECG Other images This section summarizes the application of 77 representative articles for the field of deep learning in medical image classification,detection, segmentation and generation. Pathologic image For cancer, pathological diagnosis is a gold standard in clinical practice. The conventional diagnostic way is to visually inspect histopathology images by experienced pathologists. X-ray Mammography is one of the most important modes in X-ray images and the main diagnostic tool for breast cancer. OCT and fundus image Almost all articles that we surveyed on OCT and fundus images were about classification. OCT and fundus images are diagnostic tools specifically used to examine retinal abnormalities. Diabetic retinopathy (DR), glaucomatous optic neuropathy (GON) and agerelated macular degeneration (AMD) are common retinal diseases. Endoscopic image Endoscopy produces video and it always takes a long timeto analyze, even for professional endoscopists. There have beenNarrow band imaging (NBI) â€” based deep learning studies aboutdistinguishing normal and abnormal colorectal polyps [44,45].NBI is one of the most important forms of endoscopy, with threemodes of far focus, near focus and normal focus. Dermoscopic image Dermoscopic image-based deep learning models are oftenused to diagnose melanoma. There are two related studies fromHeidelberg University in Germany. EEG / ECG EEG and ECG are biological signals and usually seen in clinicaldiagnosis with special image modalities. 0.2 Applications of detection Endoscopic image X-ray and CT Other images Endoscopic image Detection is more challenging in endoscopy than in otherordinary images. For colonoscopy, it consists of thousands offrames, probably 20â€“35 frames per second. The polyp can bedetected in only a few frames [68]. Therefore, real-time detectionin endoscopy is of great significance. X-ray and CT Both chest radiograph and CT are widely used in clinical diagnosis. Chest radiograph requires less dose but has poorer image quality. In contrast, CT has a wider range of applicationsand higher image quality. However, even low dose CT scansrequire 50â€“100 times radiation dose than single-view chest radiograph [74] 03 Applications of segmentation MRI CT Other images MRI MRI has a superior high-resolution soft-tissue contrast andcan display lesions from multiple views (horizontal, coronal, andsagittal, for example). Therefore, it has been most widely used inthe diagnosis of pelvic, heart, brain, knee joints and other parts. CT Roy et al. [81] developed a framework based on few-shortlearning and â€˜squeeze &amp; exciteâ€™ blocks to realize CT volumetricimage segmentation. Chen et al. [94] achieved a bidirectionalcross-modality adaptation between MRI and CT images via imageand feature alignment. 04 pplications for image generation This section is highly relevant to PET, CT and MR, and GAN iswidely welcomed here. In fact, considerable articles also belongto the segmentation task. Here we set them as a separate imagegeneration section, including image generation in a narrow sense,image translation, image denoising, image reconstruction, imageattenuation correction, and so on. The analysis of medical images is an important tool for clinicaldiagnosis. In this survey, 2068 articles published on PubMedon and before June 26, 2020 about deep learning in medicalimages were reviewed. The number of articles has experiencedexponential growth since 2017. The main contribution in this survey is providing a descriptiveframework for reviewing and using LDA as a quick analysis toolfor literature review. "},{"title":"Incomplete-view oriented kernel learning method with generalization error bound","date":"2022-06-07T16:00:00.000Z","url":"/2022/06/08/KernelLearning/","tags":[["Kernel_Learning","/tags/Kernel-Learning/"]],"categories":[["Artificial Intelligence","/categories/Artificial-Intelligence/"]],"content":" Whatâ€™s the difference between Multimodal Machine Learning and Multi-view Learning? How to define the specific concept? Are the two terms refer to the same thing? Is the the RPSVM-2V solution just linear Integration of RSVM and PSVM-2V? According to the data completeness, jump to the certain branch by â€œIFâ€? 0.1 KL(Kernel Methods) Support Vector Machines (SVM) Radial Basis Function (RBF) Linear Discriminate Analysis (LDA) Kernels or kernel methods (also called Kernel functions) are sets of different types of algorithms that are being used for pattern analysis. They are used to solve a non-linear problem by using a linear classifier. Kernels Methods are employed in SVM (Support Vector Machines) which are used in classification and regression problems. Support Vector Machines (SVM) In machine learning, support-vector machines (SVMs, also support-vector networks) are supervised learning models with associated learning algorithms that analyze data for classification and regression analysis. æœ€ä¼˜å‚æ•°çš„SVMå†³ç­–å‡½æ•°ï¼š $$f(x)=\\text{sgn}(w^{T}x+b^)=\\text{sgn}(\\sum_{n=1}^N \\lambda_n^y^n(x^n)^Tx+b^)$$ åœ¨ä¸€ä¸ªå˜æ¢åçš„ç‰¹å¾ç©ºé—´ä¸­ï¼ŒSVMçš„å†³ç­–å‡½æ•°ï¼š $$f(x) = sgn(w^T\\phi(x)+b^*) = sgn(\\sum_{n=1}^N \\lambda_n^y^nK(x^n,x)x+b^)$$ å…¶ä¸­æ ¸å‡½æ•°ï¼ˆKernelï¼‰ä¸ºï¼š Radial Basis Function (RBF) A radial basis function (RBF) is a real-valued function Ï† whose value depends only on the distance between the input and some fixed point, either the origin, so that Ï†(ğ±)=Ï†(|ğ±|), or some other fixed point ğœ, called a center, so that Ï†(ğ±)=Ï†(|ğ±-ğœ|). Any function Ï† that satisfies the property Ï†(ğ±)=Ï†(|ğ±|) is a radial function. The distance is usually Euclidean distance, although other metrics are sometimes used. Linear Discriminate Analysis (LDA) Linear discriminant analysis (LDA), normal discriminant analysis (NDA), or discriminant function analysis is a generalization of Fisherâ€™s linear discriminant, a method used in statistics and other fields, to find a linear combination of features that characterizes or separates two or more classes of objects or events. The resulting combination may be used as a linear classifier, or, more commonly, for dimensionality reduction before later classification. 0.2 MKL(Multiple Kernel Learning) Supervised learning Fixed rules approaches Heuristic approaches Optimization approaches Bayesian approaches Boosting approaches Semi-Supervised learning UnSupervised learning Multiple kernel learning refers to a set of machine learning methods that use a predefined set of kernels and learn an optimal linear or non-linear combination of kernels as part of the algorithm. Reasons to use multiple kernel learning include a) the ability to select for an optimal kernel and parameters from a larger set of kernels, reducing bias due to kernel selection while allowing for more automated machine learning methods, and b combining data from different sources that have different notions of similarity and thus require different kernels. Instead of creating a new kernel, multiple kernel algorithms can be used to combine kernels already established for each individual data source. Multiple kernel learning (MKL) algorithms aim to find the best convex combination of a set of kernels to form the best classifier. Many algorithms have been presented in recent years and they form two classes. Supervised learning Fixed rules approaches Heuristic approaches These algorithms use a combination function that is parameterized. we can define Other approaches use a definition of kernel similarity, such as Optimization approaches These approaches solve an optimization problem to determine parameters for the kernel combination function. This has been done with similarity measures and structural risk minimization approaches. For similarity measures such as the one defined above, the problem can be formulated as follows:[9] $$\\max_{\\beta,\\operatorname {tr}(Kâ€™{tra})=1,Kâ€™\\geq 0}A(Kâ€™{tra},YY^{T}).$$ Bayesian approaches Bayesian approaches put priors on the kernel parameters and learn the parameter values from the priors and the base algorithm. For example, the decision function can be written as Boosting approaches Boosting approaches add new kernels iteratively until some stopping criteria that is a function of performance is reached. An example of this is the MARK model developed by Bennett et al. (2002) [14] Semi-Supervised learning Let be the labeled data, and let be the set of unlabeled data. Then, we can write the decision function as follows. The problem can be written as where is the loss function (weighted negative log-likelihood in this case), is the regularization parameter (Group LASSO in this case), and is the conditional expectation consensus (CEC) penalty on unlabeled data. The CEC penalty is defined as follows. Let the marginal kernel density for all the data be where (the kernel distance between the labeled data and all of the labeled and unlabeled data) and is a non-negative random vector with a 2-norm of 1. The value of is the number of times each kernel is projected. Expectation regularization is then performed on the MKD, resulting in a reference expectation and model expectation . Then, we define where is the Kullback-Leibler divergence. The combined minimization problem is optimized using a modified block gradient descent algorithm. For more information, see Wang et al.[15] UnSupervised learning Combining these terms, we can write the minimization problem as follows. where . One formulation of this is defined as follows. Let be a matrix such that means that and are neighbors. Then, . Note that these groups must be learned as well. Zhuang et al. solve this problem by an alternating minimization method for and the group . For more information, see Zhuang et al.[16] 0.3 MVL(Multi-view Learning) Data in reality often exhibit in multi-modal forms, called multi-view data. Each view distributed in distinct feature spacesdescribes different attributes of the same object with high dimension, strong heterogeneity and rich description. The performance of multi-view learning models compares more favorably than that of single-view learning models. The existing MVLapproaches either comply with the consensus principle or the complementary principle. Here we mainly review SVM-basedMVL classification methods. 1.1 Multi-view data and learning The simplest way is to train the model on the concatenated view. However, this approach ignores the correlation and interaction among views, which may cause overfitting and dimension disasters [3,4]. In this case, multi-view learning (MVL) has emerged and achieved great success in classification [5], clustering[6,7], feature selection [8,9], etc. With the help of different kinds sensor equipment, data tracking from different aspects is much easier. In most of the cases, multi modal data gives a better view of a certain event, characterising the specific object in comprehensive way, by providing more information. 1.2 Incomplete multi-view data In real-world applications, we often confront an obstacle that only partial views are available, due to the difficulties of highcost, equipment failure, and so on [13]. Thus, learning with multiple incomplete views is a challenging yet valuable work. Unfortunately, the aforementioned strategies may either lose important information or introduce some errors, especially for the case where the amount of incomplete multi-view data is particularly large. In contrast, learning from massive complete-view data without view-missing is also complicated and time-consuming. reduced support vector machine (RSVM) multi-view privileged support vector machine (PSVM-2V) mix solution RPSVM-2V(Integration with RSVM and PSVM-2V) RSVM The RSVM can be expressed as follows: PSVM-2V To begin with, we can directly reformulate PSVM-2V (1) for incomplete-view learning, as shown below. $$s.t. \\enspace \\enspace \\enspace \\enspace |[[&lt;W_{A_1},\\Phi_{A_1}&gt;]]l^r-[[&lt;w_{A_2}&gt;,\\Phi{A_2}]]_l^r |\\le \\eta+e\\epsilon,$$ $$[[\\xi^{A_2}]]l^r \\ge [[D_1&lt;W_{A_1,\\Phi_{A_1}}&gt;]]l^r,\\xi^{A_1},\\xi^{A_2},\\eta \\ge 0, W{A_k} = \\sum{n=1}^N v_{A_k}^{j} \\phi_{k} (X_{j}^{A_k}) $$.Then problem (3) can be rewritten as follows. $$s.t.\\enspace \\enspace \\enspace \\enspace|[[K_{A_1}(A_1,A_1â€™)v_{A_1}]]l^r-[[K{A_2}(A_2,\\overline{A_2â€™}v_{A_2})]]| \\le \\eta + e \\epsilon$$ $$[[\\xi^{A_1}]]l^r \\ge [[D_2(K{A2,A_2â€™}v_{A_2})]]_l^r$$ $$[[\\xi^{A_2}]]l^r \\ge [[D_1(K{A1,A_1â€™}v_{A_1})]]_l^r$$ RPSVM-2V(*****) Formally, RPSVM-2V can be built as follows. $$[[\\xi^{A_1}]]l^r \\ge [[D_2 \\widetilde{K{A_2}}(A_2,\\overline{A_2â€™})\\widetilde{v_{A_2}}]]_l^r$$ $$[[\\xi^{A_2}]]l^r \\ge [[D_1 \\widetilde{K{A_1}}(A_1,\\overline{A_1â€™})\\widetilde{v_{A_1}}]]_l^r\\xi^{A_1},\\xi^{A_2},\\eta \\ge 0.$$ generalization error bound Generalized performance parameter study In this section, proof and algorithm are stated in detial for the final expriment output. In this paper, we propose a new model RPSVM-2V by integrating RSVM with PSVM-2V in incomplete- and complete-viewscenarios. RPSVM-2V can not only fully leverage all available information for the incomplete views case, but also achievecomparable performance with less computation and storage cost in the complete-view setting. "},{"title":"Latex for Hexo Markdown Engine","date":"2020-05-12T16:00:00.000Z","url":"/2020/05/13/LatexLearning/","tags":[["Latex_Learning","/tags/Latex-Learning/"]],"categories":[["Software Engineering","/categories/Software-Engineering/"]],"content":"æœ¬æ–‡ä¸»è¦å¯¹Latexåœ¨Markdownä¸­çš„æ¸²æŸ“è¯­æ³•è¿›è¡Œå­¦ä¹ å’Œç†Ÿæ‚‰ ç¬¬ä¸€éƒ¨åˆ†:å¸Œè…Šå­—æ¯åŸºç¡€è¡¨è¾¾ å®é™…æ¸²æŸ“æ•ˆæœå¦‚ä¸‹ æ­£å¸¸å’Œå˜ä½“ æ­£å¸¸å’Œå˜ä½“ é¦–å­—æ¯å¤§å†™ï¼Œå¯¹åº”å¸Œè…Šå­—æ¯ä¹Ÿå¤§å†™ ç¬¬äºŒéƒ¨åˆ†ï¼šå…¬å¼ä¸Šä¸‹æ ‡å¤„ç† ç”¨å¤§æ‹¬å·åŒ…è£¹å¤šé¡¹å¼ä¸‹æ ‡æ˜¯æ–œä½“è¿˜æ˜¯ç›´ç«‹ä½“çš„å’Œçš„åŒºåˆ«å’Œå¯¹åé¢çš„ä½œç”¨åŸŸåŒºåˆ«æ³¨æ„é‡Œé¢æ˜¯ç”¨å¤§æ‹¬å·è€Œä¸æ˜¯å°æ‹¬å·ä½œä¸ºä½œç”¨åŸŸçš„å¸¸é‡å»ºè®®ç”¨ç›´ç«‹ä½“çš„å­—æ¯ ç¬¬ä¸‰éƒ¨åˆ†ï¼šåˆ†å¼å’Œæ ¹å¼çš„è¡¨è¾¾ åˆ†å¼è¯­æ³•ï¼šåˆ†å­åˆ†æ¯åµŒå¥—åˆ†å¼ï¼šåˆ†å­ä¸­çš„è¾ƒå°ï¼Œæ”¹ä¸ºè°ƒæ•´æ ¼å¼æ ¹å¼æ¬¡æ–¹æ ¹ ç¬¬å››éƒ¨åˆ†ï¼šæ•°å­¦è¿ç®—ç¬¦ ç¬¬äº”éƒ¨åˆ†ï¼šç‰¹æ®Šè¿ç®—ç¬¦å’Œå‡½æ•° åŠ å…¥ï¼Œåˆ™çš„è§’æ ‡åœ¨çš„ä¸‹æ–¹ ç¬¬å…­éƒ¨åˆ†ï¼šå¤§å‹è¿ç®—ç¬¦ è¿™é‡Œä¸Šä¸‹é™å‡ç°å®åœ¨æ±‚å’Œæ±‚ç§¯çš„å³ä¾§ï¼Œè‹¥æ˜¾ç¤ºåœ¨ä¸Šä¸‹ä¾§éœ€è¦åŠ å…¥limitsé™å®šå¦‚ä¸‹æ­¤å¤„æ›²é¢ç§¯åˆ†å’Œçƒé¢ç§¯åˆ†æ— æ³•æ­£ç¡®æ¸²æŸ“ï¼Œé—®é¢˜å¾…è§£å†³ä½†åœ¨ä¸¥è°¨åœºåˆä¸­çš„ä¸ºç›´ç«‹ä½“ï¼Œä¸”ä¸è¢«ç§¯å‡½æ•°åº”è¯¥æ‹‰å¼€ä¸€æ®µå°é—´éš” ç¬¬ä¸ƒéƒ¨åˆ†ï¼šæ ‡æ³¨ç¬¦å·ã€ç®­å¤´ã€å®šç•Œç¬¦ æ ‡æ³¨ç¬¦å·ï¼šä¸Šé¢ä¸€ä¸ªå³ç®­å¤´ä¸Šé¢ä¸€ä¸ªæ¨ªçº¿ç®­å¤´å•ç®­å¤´åŒç®­å¤´æ‹¬å·å’Œå®šç•Œç¬¦ï¼šå¤§æ‹¬å·çš„å·¦å³æ‹¬å·è¦åŠ è½¬ä¹‰é«˜åº¦è‡ªé€‚åº”çš„æ‹¬å·ï¼šä¸ºäº†è‡ªé€‚åº”ç«–çº¿ï¼Œæ„é€ äº†è™šæ‹Ÿçš„å·¦æ‹¬å·ï¼š ç¬¬å…«éƒ¨åˆ†ï¼šå¤šè¡Œå…¬å¼å’ŒçŸ©é˜µ å…¶ä»– "},{"title":"Tiny JavaScript Compiler","date":"2018-10-01T15:00:00.000Z","url":"/2018/10/01/2018-10-24-Tiny-Compiler/","tags":[["Compilers","/tags/Compilers/"],["Lexical Analysis","/tags/Lexical-Analysis/"],["Syntax Analysis","/tags/Syntax-Analysis/"],["Computer Science","/tags/Computer-Science/"]],"categories":[["Compilers","/categories/Compilers/"],["Lexical Analysis","/categories/Compilers/Lexical-Analysis/"],["Syntax Analysis","/categories/Compilers/Lexical-Analysis/Syntax-Analysis/"],["Computer Science","/categories/Compilers/Lexical-Analysis/Syntax-Analysis/Computer-Science/"]],"content":" I already wrote a couple of essays related to the development of programming languages that I was extremely excited about! For instance, in â€œStatic Code Analysis of Angular 2 and TypeScript Projectsâ€œ[1] I explored the basics of the front end of the compilers, explaining the phases of lexical analysis, syntax analysis and abstract-syntax trees. Recently I published â€œDeveloping Statically Typed Programming Languageâ€œ[2]. This post shown a simple, statically typed, functional programming language inspired by lambda calculus. There I outsourced the front end part of the compiler development to a parser generator and focused on the back end in the faces of a module for type checking and one for code generation. Why do I need this?You might be now wondering â€œWhy would I need to know how to develop a compiler?â€œ. There are a few important reasons: You will get a better understanding of how the programming languages youâ€™re using work. This will allow you to develop more efficient programs with them. Often, youâ€™ll have to reuse pieces of the modules described below for different purposes (for instance, parsing of configuration files, parsing of network messages, etc.). Creating a DSL. Creating a Domain Specific Language in your project could be quite handy in order to simplify tasks which otherwise take a lot of time to solve with a general purpose programming language. What are we going to cover?In this blog post weâ€™ll cover the basics from end-to-end! Weâ€™ll develop an extremely simple compiler on 25 lines of JavaScript! Our compiler will have: Module for lexical analysis Module for syntax analysis The parser will be based on an EBNF grammar We will develop the parser by using a recursive descent parsing algorithm Code generator The language that weâ€™re going to explore is not particularly useful for developing meaningful software programs but it can be easily extended to one. The entire implementation can be found at my GitHub profile[3]. Introducing a Simple Prefix LanguageHereâ€™s how a sample expression in our language is going to look like: By the end of this article weâ€™ll be able to transpile these expressions to JavaScript by going through phases typical for any compiler! For simplicity, there are a few rules we need to follow: We have only the functions: mul, sub, sum, div. Each individual string token is surrounded by whitespace. We support only natural numbers. In order to explore the semantics behind the expression above lets define a few JavaScript functions: mul accepts multiple operands, passed with the spread operator. The function just multiplies all of them, so for instance mul(2, 3, 4) === 24. sub respectively subtracts the passed arguments and sum sums them. The expression above can be translated to the following JavaScript expression: orâ€¦ Now, after we have understanding of the semantics, lets start with the front end of the compiler! Note: Similar prefix expressions can be simply evaluated with a stack-based algorithm, however, in this case weâ€™ll focus on concepts rather than implementation. Developing the Compilerâ€™s Front EndThe front end of any compiler usually has the modules for Lexical Analysis[4] and Syntax Analysis[5]. In this section weâ€™ll build both modules in a few lines of JavaScript! Developing a Lexical AnalyzerThe phase of lexical analysis is responsible for dividing the input string (or stream of characters) of the program into smaller pieces called tokens. The tokens usually carries information about their type (if they are numbers, operators, keywords, identifiers, etc), the substring of the program they represent and their position in the program. The position is usually used for reporting user friendly errors in case of invalid syntactical constructs. For instance, if we have the JavaScript program: A sample lexical analyzer for JavaScript will produce the output: Weâ€™ll keep our lexical analyzer as simple as possible. In fact, weâ€™ll implement it on a single line of JavaScript: Here we split the string by a single space, we map the produced substrings to their trimmed version and filter the empty strings. Invoking the lexer with an expression will produce an array of strings: This is completely enough for our purpose! Now lets go to the phase of syntax analysis! Developing a ParserThe syntax analyzer (often know as parser) is the module of a compiler which out of a list (or stream) of tokens produces an Abstract Syntax Tree[6] (or in short an AST). Along the process, the syntax analyzer may also produce syntax errors in case of invalid programs. Usually, the parser is implemented based on a grammar[7]. Hereâ€™s the grammar of our language: This basically means that we have digits which composed together can form numbers (num). We have 4 operations and an expression can be either a number, or operation, followed by one or more expressions. Weâ€™ll refer to the individual definitions in the grammar (for instance to num and op) as rules. This is the so called EBNF grammar[6]. Look at the grammar for a bit, try to understand it, and after that completely forget about it! Weâ€™ll come back to the grammar after we explain the parser and youâ€™ll see how everything connects together! As we mentioned, a parser is a tool which turns a list of tokens to an AST. For instance, for our expression: The parser will produce the following AST, based on the grammar above: Lets explore the algorithm for this! The bad news is that there are a lot of things going on. The good news is that this is the most complicated part of the compiler! Lets divide the code into parts and look into each one step by step. Node Types First we define the different node types that we are going to have in the AST. Weâ€™ll have only numbers and operations. For example, the number node 42 will look like this: The operator sum, applied to 2, 3, 4 will look like this: Thatâ€™s how simple is that! The ParserAfter we declare the node types, we define a function called parse which accepts a single argument called tokens. Inside of it we define five more functions: peek - returns the element of tokens associated with the current value of the c local variable. consume - returns the element of tokens associated with the current value of the c local variable and increments c. parseNum - gets the current token (i.e. invokes peek()), parses it to a natural number and returns a new number token. parseOp - weâ€™ll explore in a little bit. parseExpr - checks if the current token matches the regular expression /\\d/ (i.e. is a number) and invokes parseNum if the match was successful, otherwise returns parseOp. Parsing OperationsThe parseOp is maybe the most complicated function from the parser above. Thatâ€™s the case because of the loop and the indirect recursion that we have. Hereâ€™s its definition one more time in order to explain it line by line: Since parseOp has been invoked by parseExpr when the value of peek() is not a number we know that it is an operator so we create a new operation node. Note that we donâ€™t perform any further validation, however, in a real-world programming language weâ€™d want to do that and eventually throw a syntax error in case of unexpected token. Anyhow, in the node declaration we set the list of â€œsub-expressionsâ€ to be the empty list (i.e. []), the operation name to the value of consume() and the type of the node to Op. Later, while we donâ€™t reach the end of the program, we loop over all tokens by pushing the currently parsed expression to the list of â€œsub-expressions` of the given node. Finally, we return the node. Keep in mind that while (peek()) node.expr.push(parseExpr()); performs an indirect recursion. In case we have the expression: This will First, invoke parseExpr, which will find that the current token (i.e. tokens[0]) is not a number (itâ€™s sum) so itâ€™ll invoke parseOp. After that parseOp will create the operation node and because of the consume() call, increment the value of c. Next parseOp will iterate over the tokens, and for tokens[c], where c now equals 1 will invoke parseExpr. parseExpr will find that the current token is not a number so itâ€™ll invoke parseOp. parseOp will create another operation node and increment c and will start looping over the remaining tokens again. parseOp will invoke parseExpr where c will now equal 2. Since tokens[2] === \"2\", parseExpr will invoke parseNum which will create a number node, incrementing the c variable. parseNum will return the number node and it will be pushed into the expr array of the last operation node produced by the latest parseOp invocation. The last parseOp invocation will return the operation node since peek() will return undefined (parseNum has incremented c to 3 and tokens[3] === undefined). The node returned by the last invocation of parseOp will be returned to the outermost invocation of parseOp which will return its operation node as well. Finally, parseExpr will return the root operation node. The produced AST will look like: â€¦and thatâ€™s it! The final step is to traverse this tree and produce JavaScript! Recursive Descent ParsingNow lets see how are the individual functions related to the grammar we defined above and see why having a grammar makes sense in general. Lets take a look at the rules in the EBNF grammar: Do they now may make a bit more sense? expr looks very much like parseExpr, where we parse either a number or an operation. Similarly, op expr+ looks very much like parseOp and num like parseNum. In fact, very often parsers are generated directly from the grammars since thereâ€™s a direct connection between both with the recursive descent parsing algorithm[8]. And in fact, we just developed a simple recursive descent parser! Our parser was quite simple (well, we have only 4 production rules in the grammar) but you can imagine how complex the parser of a real-life programming language is. Itâ€™s extremely convenient to develop the grammar of a language before writing the actual parser in order to observe a simplified model of it. The parser contains a lot of details (for instance a lot of syntax constructs of the language youâ€™re developing it with), in contrast to the grammar which is extremely simplified and minimalistic. Developing the TranspilerIn this part of the post weâ€™ll traverse the AST of the language and produce JavaScript. The entire transpiler is on 7 lines of JavaScript (literally!): Lets explore the implementation line by line. First we define a function called transpile. It accepts as argument the AST produced by the parser. After that in the opMap we define the mapping between arithmetic operations and the operators in the language. Basically, sum maps to +, mul to *, etc. As next step, we define the function transpileNode which accepts an AST node. If the node is a number, we invoke the transpileNum function with the given node, otherwise, we invoke transpileOp. Finally, we define the two functions for transpilation of the individual nodes: transpileNum - translates a number to a JavaScript number (simply by returning it). transpileOp - translates an operation to a JavaScript arithmetic operation. Notice that we have indirect recursion here (transpileOp -&gt; transpileNode -&gt; transpileOp). For each operation node, we want to transpile its sub-expressions first. We do that by invoking the transpileNode function. On the last line of transpileâ€˜s body, we return the result of transpileNode applied to the root of the tree. Wiring Everything TogetherHereâ€™s how we can wire everything together: We invoke lex(program), which produces the list of tokens, after that we pass the tokens to the parse function, which produces the AST and finally, we transpile the AST to JavaScript! ConclusionThis article explained in details the development of a very simple compiler (or transpiler) of a language with prefix expressions to JavaScript. Although this was explanation of only the very basics of the compiler development we were able to cover few very important concepts: Lexical analysis Syntax analysis Source code generation EBNF grammars Recursive Descent Parsing If youâ€™re interested in further reading, Iâ€™d recommend: Developing Statically Typed Programming Language Letâ€™s Build A Simple Interpreter Compilers: Principles, Techniques, and Tools (2nd Edition) 2nd Edition Types and Programming Languages References Static Code Analysis of Angular 2 and TypeScript Projects - . Developing Statically Typed Programming Language -  Tiny Compiler -  Lexical Analysis -  Syntax Analysis -  Abstract Syntax Tree -  EBNF grammar -  Recursive Descent Parsing -  "},{"title":"Semantic Knowledge and its Application","date":"2017-06-26T15:00:00.000Z","url":"/2017/06/26/2017-06-27-Semantic-knowledge-and-application/","tags":[["Computational Linguistics Semantics","/tags/Computational-Linguistics-Semantics/"]],"categories":[["Computational-Linguistics","/categories/Computational-Linguistics/"]],"content":"è¯­ä¹‰å­¦ï¼ˆSemanticsï¼‰ï¼Œä¹Ÿä½œâ€œè¯­æ„å­¦â€ï¼Œæ˜¯ä¸€ä¸ªæ¶‰åŠåˆ°è¯­è¨€å­¦ã€é€»è¾‘å­¦ã€è®¡ç®—æœºç§‘å­¦ã€è‡ªç„¶è¯­è¨€å¤„ç†ã€è®¤çŸ¥ç§‘å­¦ã€å¿ƒç†å­¦ç­‰è¯¸å¤šé¢†åŸŸçš„ä¸€ä¸ªæœ¯è¯­ã€‚ è™½ç„¶å„ä¸ªå­¦ç§‘ä¹‹é—´å¯¹è¯­ä¹‰å­¦çš„ç ”ç©¶æœ‰ä¸€å®šçš„å…±åŒæ€§ï¼Œä½†æ˜¯å…·ä½“çš„ç ”ç©¶æ–¹æ³•å’Œå†…å®¹å¤§ç›¸å¾„åº­ã€‚è¯­ä¹‰å­¦çš„ç ”ç©¶å¯¹è±¡æ˜¯è‡ªç„¶è¯­è¨€çš„æ„ä¹‰ï¼Œè¿™é‡Œçš„è‡ªç„¶è¯­è¨€å¯ä»¥æ˜¯è¯ï¼ŒçŸ­è¯­ï¼ˆè¯ç»„ï¼‰ï¼Œå¥å­ï¼Œç¯‡ç« ç­‰ç­‰ä¸åŒçº§åˆ«çš„è¯­è¨€å•ä½ã€‚ä½†æ˜¯å„ä¸ªé¢†åŸŸé‡Œå¯¹è¯­è¨€çš„æ„ä¹‰çš„ç ”ç©¶ç›®çš„ä¸åŒï¼š è¯­è¨€å­¦çš„è¯­ä¹‰å­¦ç ”ç©¶ç›®çš„åœ¨äºæ‰¾å‡ºè¯­ä¹‰è¡¨è¾¾çš„è§„å¾‹æ€§ã€å†…åœ¨è§£é‡Šã€ä¸åŒè¯­è¨€åœ¨è¯­ä¹‰è¡¨è¾¾æ–¹é¢çš„ä¸ªæ€§ä»¥åŠå…±æ€§ï¼› é€»è¾‘å­¦çš„è¯­ä¹‰å­¦æ˜¯å¯¹ä¸€ä¸ªé€»è¾‘ç³»ç»Ÿçš„è§£é‡Šï¼Œç€çœ¼ç‚¹åœ¨äºçœŸå€¼æ¡ä»¶ï¼Œä¸ç›´æ¥æ¶‰åŠè‡ªç„¶è¯­è¨€ï¼› è®¡ç®—æœºç§‘å­¦ç›¸å…³çš„è¯­ä¹‰å­¦ç ”ç©¶åœ¨äºæœºå™¨å¯¹è‡ªç„¶è¯­è¨€çš„ç†è§£ï¼› è®¤çŸ¥ç§‘å­¦å¯¹è¯­ä¹‰å­¦çš„ç ”ç©¶åœ¨äºäººè„‘å¯¹è¯­è¨€å•ä½çš„æ„ä¹‰çš„å­˜å‚¨åŠç†è§£çš„æ¨¡å¼ã€‚ è®¡ç®—è§’åº¦ä¸‹çš„è¯­ä¹‰è¯­ä¹‰çš„é€šä¿—ç†è§£é¦–å…ˆï¼Œæˆ‘ä»¬ä»æ­£å¸¸çš„é€šä¿—æ¦‚å¿µä¸Šæ¥ç†è§£è¯­ä¹‰æ˜¯ä»€ä¹ˆã€‚åœ¨æ—¥å¸¸çš„å¯¹è¯å’Œå„ç§åœºåˆçš„è¡¨è¿°ä¸­ï¼Œé€šå¸¸ä¸€å¥è¯è¡¨è¾¾çš„ä¿¡æ¯å’Œå«ä¹‰ï¼Œæˆ‘ä»¬èƒ½å¤Ÿç”¨ä¸åŒçš„æ–¹å¼è¿›è¡Œä½“ç°ã€‚åœ¨æˆ‘ä»¬è¿˜æ˜¯å­©æçš„æ—¶å€™ï¼Œè€å¸ˆå°±æ›¾ç»æ•™è¿‡æˆ‘ä»¬é‡‡ç”¨ä¸åŒçš„æ–¹å¼å¯¹åŒä¸€ä¸ªå¥å­è¿›è¡Œæ”¹å†™ä»¥è¡¨è¾¾åŒæ ·çš„ä¿¡æ¯ã€‚ä¾‹å¦‚ï¼š â€œå¼ ä¸‰æ‰“äº†æå››â€ â€”â€”&gt; â€œæå››è¢«å¼ ä¸‰æ‰“äº†â€ åœ¨è¿™æ ·çš„ä¸¤ä¸ªå¥å­ä¸­ï¼Œå¥å­æœ¬èº«çš„å½¢å¼ä¸åŒï¼Œä½†æ˜¯å…¶ä¿¡æ¯ä¸­è¡¨ç¤ºçš„ä¸åŒå®ä½“ä¹‹é—´çš„å…³ç³»æ˜¯ä¸€è‡´çš„ã€‚è¿™é‡Œåœ¨è¯­ä¹‰çš„å±‚é¢ä¸Šï¼ŒåŒæ ·éƒ½æ˜¯ï¼šå¼ ä¸‰ â€œæ‰“â€ æå››ã€‚ä½†æ˜¯ï¼Œå¾ˆå¤šæ—¶å€™æˆ‘ä»¬å¹¶ä¸ä¼šè¿›è¡Œæ·±å…¥çš„æ€è€ƒï¼Œè¿™ç§å¯¹åŒæ ·è¯­ä¹‰è¿›è¡Œçš„ä¸åŒå½¢å¼çš„å±•ç°ï¼Œç©¶ç«Ÿæ„å‘³ç€ä»€ä¹ˆã€‚å°¤å…¶æ˜¯åœ¨å¤æ‚åœºæ™¯ä¸‹ï¼Œæ›´æ˜¯è¿™ç§æƒ…å†µã€‚æŸä¸€ç§è¡¨è¿°å’ŒåŸå…ˆçš„è¡¨è¿°å¯èƒ½ä¿¡æ¯è¡¨è¿°çš„ä¿¡æ¯ç›¸åŒï¼Œä½†æ˜¯åœ¨å…¶ç‰¹å®šçš„ç¯å¢ƒä¸‹ï¼Œç©¶ç«Ÿåº”è¯¥é€‰æ‹©å“ªä¸€ç§æ–¹å¼ï¼Œå¾ˆå¤šçš„æ—¶å€™ï¼Œæˆ‘ä»¬å¹¶ä¸èƒ½ç²¾ç¡®çš„æè¿°å‡ºæ¥ã€‚ ç¬¦å·å­¦ä¸Šçš„æ„ä¹‰æˆ‘ä»¬ä»çº¯ç¬¦å·å­¦çš„è§’åº¦æ¥çœ‹æ„ä¹‰ï¼Œå¯èƒ½å¹¶æ²¡æœ‰ä»€ä¹ˆæ„ä¹‰â€”â€”â€”â€”æ„ä¹‰å°±æ˜¯ç¬¦å·å˜æ¢çš„æ¸¸æˆï¼Œçº¯ç²¹ä»ç¬¦å·ä¸–ç•Œçš„è§’åº¦æ¥ç†è§£ï¼šâ€œAçš„æ„æ€æ˜¯Bâ€ or â€œAæ„å‘³ç€Bâ€ã€‚ç„¶è€Œï¼Œæ‰€è°“çŸ¥é“ä¸€ä¸ªç¬¦å·ä¸²çš„æ„ä¹‰ï¼ŒåŒ…å«ä¸¤å±‚æ„æ€ï¼š ä½ å¯ä»¥æŠŠä¸€ä¸ªç¬¦å·ä¸²Aå˜æ¢ä¸ºç¬¦å·ä¸²Bï¼› åŸåˆ™ä¸Šï¼Œå…³äºè¿™ä¸ªç¬¦å·ä¸²Açš„å˜æ¢æ¸¸æˆæ²¡æœ‰æ­¢å°½; åœ¨è‹±æ–‡ä¸­æœ‰ä¸€ä¸ªè¯ï¼Œç”¨æ¥è¡¨ç¤ºåŒæ ·æ„æ€ä¹‹é—´çš„å½¢å¼è½¬æ¢ï¼šParaphraseï¼Œä¸‹é¢æˆ‘ä»¬çœ‹ä¸€ä¸‹Collinså­—å…¸ä¸­å¯¹è¿™ä¸ªè‹±æ–‡è¯çš„è§£é‡Šã€‚ If you paraphrase someone or paraphrase somethingthat they have said or written, you express what theyhave said or written in a different way. â€”â€” Collins COBUILD Dictionary åœ¨ä¸Šè¿°çš„ç‰¹ç‚¹ä¸‹ï¼Œè‡ªç„¶è¯­è¨€ç³»ç»Ÿä¸­å› ä¸ºå½¢å¼ä¸æ„ä¹‰çš„éä¸€ä¸€å¯¹åº”æ€§ï¼Œå¯¼è‡´äº†åœ¨è®¡ç®—è¯­è¨€å­¦ä¸­å¯¹å…¶è¯­è¨€ææ–™çš„å¤„ç†æ˜¯ä¸€ä¸ªæå…¶å›°éš¾çš„è¿‡ç¨‹ã€‚ ä¸€ä¸ªå½¢å¼ â€”â€” å¤šä¸ªæ„ä¹‰:è‡ªç„¶è¯­è¨€ç†è§£å¿…é¡»é¢å¯¹çš„é—®é¢˜ ä¸€ä¸ªæ„ä¹‰ â€”â€” å¤šä¸ªå½¢å¼:è‡ªç„¶è¯­è¨€ç”Ÿæˆå¿…é¡»é¢å¯¹çš„é—®é¢˜ è¿™ä¸¤ç§ä¸å¯¹åº”ï¼Œå¦‚æœè¦è¿›è¡Œå…·ä½“çš„åˆ†ç±»å¯ä»¥åŸºæœ¬ä¸Šæ¶µç›–ä»¥ä¸‹çš„ä¸åŒç±»å‹ï¼š 1.ä¸€ä¸ªå½¢å¼å¤šé‡æ„ä¹‰çš„æƒ…å†µï¼š æ¦‚å¿µå¤šä¹‰:å¦‚â€œç¼–è¾‘â€è¿™ä¸ªè¯åŒæ—¶å…·æœ‰ä¸åŒçš„è¯æ€§ï¼Œå½“ç„¶ä¹Ÿå°±ç”¨æ³•ä¸åŒã€‚ æŒ‡ç§°å¤šä¹‰:å¦‚â€œå¼ ä¸‰æŠŠä»–å‡ºå–äº†ã€‚â€å’Œâ€œå¼ ä¸‰æŠŠä»–çš„æœ‹å‹å‡ºå–äº†ã€‚â€ä¸¤å¥ä¸­ä»–åˆ°åº•æŒ‡çš„æ˜¯è°ï¼Ÿ æ³›æŒ‡ä¸ç‰¹æŒ‡:ç•¥ é‡åŒ–è¯ç»„:ç•¥ å¸¸è§æ­§ä¹‰ç»“æ„ï¼šå¸¸è§çš„è¯­è¨€ä¸­å„ç§ç‰¹ä¾‹ï¼Œå¦‚ç‰›å¥¶é¥¼å¹²ï¼Œæ™’å¤ªé˜³ç­‰ã€‚ éšå–»:å¦‚â€è‘£æ°¸è¿™å›ç®—æ˜¯èƒŒä¸Šå£å¤§é»‘é”…äº†.â€ 2.ä¸€ä¸ªæ„ä¹‰å¤šç§å½¢å¼çš„æƒ…å†µï¼š åŒä¹‰è¯:å¦‚â€œè¡£æœ â€” è¡£è£³â€ç­‰ã€‚ åŒä¹‰ç»“æ„:å¦‚â€œå»çœ‹çœ‹â€å’Œâ€œçœ‹çœ‹å»â€ åœ¨è‡ªç„¶è¯­è¨€ä¸­ä¸Šè¿°çš„è¿™ç±»æƒ…å†µéå¸¸å¤šï¼Œå…·ä½“çš„è¯­è¨€ææ–™é›¶ç¢ï¼Œä¸”å¾ˆå¤šæ—¶å€™è¿™äº›è¯­è¨€ä¿¡æ¯å’Œä¸åŒçš„æ°‘æ—æ–‡åŒ–åˆæœ‰å¾ˆå¤§çš„å…³è”ã€‚åœ¨é¢å¯¹è¿™äº›é—®é¢˜çš„æ—¶å€™ï¼Œå°±éœ€è¦è€—è´¹ä¸€ç•ªåŠŸå¤«ã€‚ è¯­ä¹‰çŸ¥è¯†ç®€è¿°è¯­ä¹‰çŸ¥è¯†ä»è¯ä¹‰èšåˆå’Œè¯ä¹‰ç»„åˆä¸¤ç§åŸºæœ¬åŸºæœ¬çš„ç‰¹æ€§ä¸Šå¯ä»¥å¤§è‡´æŒ‰ç…§è¿™ä¸¤ä¸ªæ–¹å‘è¿›è¡Œåˆ’åˆ†ã€‚ å…³äºè¯ä¹‰èšåˆå…³ç³»çš„çŸ¥è¯†ï¼š 1.è¯­ä¹‰ç‰¹å¾ï¼ˆä¹‰ç´ ï¼‰åˆ†æ 2.è¯­ä¹‰å…³ç³»åˆ†æï¼šè¯­ä¹‰åˆ†ç±»ï¼ˆè¯­ä¹‰åœºï¼‰â€”â€” ä¸Šã€ä¸‹ä½å…³ç³»åŒä¹‰å…³ç³»ï¼›åä¹‰å…³ç³»ï¼›æ•´ä½“ - éƒ¨åˆ†å…³ç³» â€¦ ä¸Šè¿°ä¸¤ç§ä¸åŒçš„åˆ†æï¼Œå¦‚æœæ·±å…¥è¿›å»ä¼šæœ‰æ›´è¯¦ç»†çš„é˜è¿°ï¼Œä»¥åæœ‰æœºä¼šçš„è¯ï¼Œæ·±å…¥ä¸“é¢˜ã€‚è¿™é‡Œåªåšç®€å•çš„æ•´ç†åˆ†ç±»ï¼Œä»¥ä¾¿ä»å®è§‚çš„è§’åº¦çœ‹æ•´ä½“çš„æ–¹å‘ã€‚ å…³äºè¯ä¹‰ç»„åˆå…³ç³»çš„çŸ¥è¯†: ç†æƒ³ç›®æ ‡ï¼šæè¿°ä»»æ„è¯è¯­ä¹‹é—´çš„ç»„é…å…³ç³» é…ä»·ç†è®ºï¼šå…¸å‹çš„é…ä»·å…³ç³»ï¼šåŠ¨è¯ ï¼ åè¯ä¹‹é—´çš„ç»„é…å…³ç³»å¯åˆ†ä¸ºä¸‰ä¸ªå±‚æ¬¡æ¥æè¿°è¿™ç§ç»„é…å…³ç³»çŸ¥è¯†: 1.è®ºå…ƒä¸ªæ•° â€”â€” ä»·æ•° 2.è®ºå…ƒç±»å‹ â€”â€” è®ºæ—¨è§’è‰² 3.å¯¹è®ºæ—¨è§’è‰²çš„é€‰æ‹©é™åˆ¶ åœ¨è¯ä¹‰ç»„åˆçš„æ–¹é¢ï¼Œæœ‰ç€æ›´ä¸ºè¯¦ç»†çš„å¤„ç†ï¼Œç»†èŠ‚å¾ˆå¤šï¼Œè¿™é‡Œä¹Ÿä¸åšæ·±å…¥ã€‚ è¯­ä¹‰çŸ¥è¯†çš„åº”ç”¨è¯­ä¹‰çŸ¥è¯†è·Ÿå¥æ³•çŸ¥è¯†çš„å·®åˆ«ä¸»è¦åœ¨äºçŸ¥è¯†é¢—ç²’åº¦çš„ä¸åŒï¼Œä»æŸç§æ„ä¹‰ä¸Šè¯´ï¼Œè¯­ä¹‰çŸ¥è¯†å°±æ˜¯ç»†åŒ–äº†çš„å¥æ³•çŸ¥è¯†ã€‚ è¯­ä¹‰çŸ¥è¯†çš„åº”ç”¨ï¼š å¸®åŠ©åˆ¤æ–­ä¸€ä¸ªå½¢å¼çš„åˆè¯­æ³•æ€§ï¼Œå¸®åŠ©åšå¥æ³•ç»“æ„åˆ†æ å¸®åŠ©åšå½¢å¼å˜æ¢ï¼šå¾—åˆ°åŒä¹‰è¡¨è¾¾å¼ï¼Œè¿›è¡Œæ¨ç†ï¼Œç­‰ç­‰ ä»æœ¬è´¨ä¸Šæ¥è¯´ï¼Œè¯­ä¹‰çŸ¥è¯†æœ¬èº«ä¹Ÿæ˜¯ä¸€ç§å½¢å¼åŒ–çš„æ•°æ®é›†åˆã€‚åœ¨ä¸åŒçš„æƒ…å†µä¸‹ï¼Œè¯­ä¹‰æœ¬èº«çš„åŸåˆ™å¯¹è¯­è¨€ææ–™åšå‡ºä¸€å®šçš„æŒ‡å¯¼ä½œç”¨ã€‚ä¸Šé¢æ‰€è¯´çš„ä¸¤ç§åº”ç”¨ï¼Œç¬¬ä¸€ç§æ˜¯åœ¨è¯­ä¹‰çŸ¥è¯†çš„åŸºç¡€ä¸Šç”¨æ¥å¯¹å®é™…çš„è¯­è¨€ç‰¹å¾è¿›è¡Œç­›é€‰ã€‚ç¬¬äºŒç§ï¼Œåˆ™æ˜¯åœ¨å˜æ¢è§„åˆ™çš„åŸºç¡€ä¸Šï¼Œå¯¹æŸç§ç¬¦åˆè¯­ä¹‰çŸ¥è¯†çš„è¯­è¨€ææ–™è¿›è¡Œæ˜ å°„çš„è¿‡ç¨‹ã€‚ è¯¦ç»†çš„ä¾‹å­ï¼Œè¿™é‡Œä¹Ÿä¸åšè¿‡åˆ†çš„ç»†è¯´ã€‚åœ¨æ­¤è¿‡ç¨‹ä¸­ï¼Œä¼šäº§ç”Ÿå¾ˆå¤šçš„é—®é¢˜ï¼Œæ¥ä¸‹æ¥åœ¨ç†è®ºå·¥å…·çš„å‘å±•ä¸‹ï¼Œæ¥ä¸€æ­¥æ­¥äº†è§£ï¼šå¯¹è¿™äº›å…·ä½“çš„é—®é¢˜ï¼Œæ€æ ·ç”¨è®¡ç®—çš„æ–¹å¼è¿›è¡Œè§£å†³ï¼Ÿè¿™æ˜¯ä¸€ä¸ªè‰°è‹¦çš„è¿‡ç¨‹ã€‚ è®²ä¹‰æœ€åçš„æ–‡çŒ® å†¯å¿—ä¼Ÿç­‰è¯‘ï¼ˆ2005ï¼‰ã€Šè‡ªç„¶è¯­è¨€å¤„ç†ç»¼è®ºã€‹ç¬¬14ï¼Œ15ï¼Œ16ç« ã€‚ è©¹å«ä¸œï¼Œ2001ï¼Œã€Šç¡®ç«‹è¯­ä¹‰èŒƒç•´çš„åŸåˆ™åŠè¯­ä¹‰èŒƒç•´çš„ç›¸å¯¹æ€§ã€‹ï¼Œè½½ã€Šä¸–ç•Œæ±‰è¯­æ•™è‚²ã€‹2001å¹´ç¬¬2æœŸã€‚ å¾çƒˆç‚¯ï¼Œ1995ï¼Œã€Šè¯­ä¹‰å­¦ã€‹ï¼Œè¯­æ–‡å‡ºç‰ˆç¤¾ Geoffrey Leech, 1983, Semantics: The Study * of Meaning, Penguin Books. è’‹ä¸¥ï¼Œæ½˜æµ·åï¼Œ1998ï¼Œã€Šå½¢å¼è¯­ä¹‰å­¦å¼•è®ºã€‹ï¼Œä¸­å›½ç¤¾ä¼šç§‘å­¦å‡ºç‰ˆç¤¾ Shalom Lappin, ed., 1996, The Handbook of Contemporary Semantic Theory, Oxford:Blackwell. å§šå¤©é¡º ç­‰, 1995, ã€Šè‡ªç„¶è¯­è¨€ç†è§£ã€‹ï¼Œæ¸…åå¤§å­¦å‡ºç‰ˆç¤¾ï¼Œç¬¬å››ç« ï¼Œpp50-81, ï¼ˆè¯­ä¹‰ç½‘ç»œï¼‰ å¼ æ™®,1991,ã€Šä¿¡æ¯å¤„ç†ç”¨ç°ä»£æ±‰è¯­è¯­ä¹‰åˆ†æçš„ç†è®ºä¸æ–¹æ³•ã€‹ï¼Œè½½ã€Šä¸­æ–‡ä¿¡æ¯å­¦æŠ¥ã€‹1991å¹´ç¬¬3æœŸã€‚ "},{"title":"Language and history","date":"2017-06-01T15:00:00.000Z","url":"/2017/06/01/2017-06-01-Linguistics-and-history/","tags":[["Linguistics","/tags/Linguistics/"]],"categories":[["Linguistics","/categories/Linguistics/"]],"content":"è¯­è¨€æ˜¯ä¸€ä¸ªå¾ˆç¥å¥‡çš„å­˜åœ¨ï¼Œå‡ ä¹æ¯ä¸ªæ­£å¸¸çš„æˆå¹´äººéƒ½çŸ¥é“ä»€ä¹ˆæ˜¯è¯­è¨€ï¼Œéƒ½çŸ¥é“æ€ä¹ˆä½¿ç”¨è¯­è¨€ã€‚åœ¨ä½¿ç”¨çš„æ—¶å€™ï¼Œå¤§éƒ¨åˆ†äººéƒ½ä¼šä»ä¸€ä¸ªäººä½¿ç”¨è¯­è¨€çš„è¿‡ç¨‹ä¸­äº§ç”Ÿä¸€äº›åŸºæœ¬çš„åˆ¤æ–­ã€‚æ¯”å¦‚æ„Ÿè§‰æŸä¸€ä¸ªäººå¾ˆä¼šè¯´è¯ï¼ŒæŸä¸€ä¸ªäººè¯´è¯æ€»æ˜¯å¾ˆéš¾å¬ï¼Œæˆ–è€…æŸä¸ªäººè¯´è¯çš„æ—¶å€™å¾ˆæœ‰å¹½é»˜æ„Ÿï¼ŒæŸä¸ªäººè¯´çš„è¯å¾ˆæ¶ˆæä¹‹ç±»ã€‚ ç„¶è€Œå¾ˆå¤šæ—¶å€™ï¼Œæˆ‘ä»¬å¹¶ä¸ä¼šæ·±å…¥å»æƒ³è¿™äº›é—®é¢˜ï¼Œä¸ºä»€ä¹ˆæˆ‘ä»¬åœ¨è¿›è¡Œè¯­è¨€äº’åŠ¨çš„è¿‡ç¨‹ä¸­ï¼Œä¼šäº§ç”Ÿè¿™æ ·æˆ–è€…é‚£æ ·çš„åˆ¤æ–­ã€‚ç©¶ç«Ÿæ˜¯è¯­è¨€ä¸­çš„å“ªäº›éƒ¨åˆ†å†³å®šäº†æˆ‘ä»¬äº§ç”Ÿäº†æŸç§æƒ³æ³•å‘¢ï¼Ÿè¿™äº›é—®é¢˜å¹¶ä¸åƒçœ‹ä¸Šå»é‚£ä¹ˆå®¹æ˜“æ‰¾åˆ°ç­”æ¡ˆã€‚ç”Ÿç†ä¸Šçœ‹ï¼Œè¯­è¨€ä»…ä»…æ˜¯äººç±»çš„å£°å¸¦åœ¨ä¸€å®šæ–¹å¼çš„éœ‡åŠ¨ä¸‹å‘å‡ºçš„ç‰¹å®šé¢‘ç‡çš„å£°æ³¢ï¼Œç„¶åä¼ åˆ°æˆ‘ä»¬çš„è€³æœµä¸­ï¼Œå¤§è„‘æ¥æ”¶åˆ°è¿™äº›å£°æ³¢ã€‚ç„¶è€Œï¼Œåœ¨ä¸€ä¸ªäººå‘å‡ºâ€Hello Worldâ€ è¿™æ ·ä¸€ä¸ªå£°éŸ³ï¼Œå¹¶ä¼ åˆ°æˆ‘çš„è€³æœµä¸­ä¹‹åï¼Œæˆ‘å¹¶ä¸çŸ¥é“ï¼Œæˆ‘çš„å¤§è„‘åšäº†å“ªäº›å·¥ä½œï¼Œå¹¶ä½¿æˆ‘å°†å£°éŸ³çš„ä¿¡æ¯å’Œâ€œä½ å¥½â€ï¼Œâ€œä¸–ç•Œâ€è¿™æ ·çš„æ¦‚å¿µè”ç³»åˆ°äº†ä¸€èµ·ã€‚æˆ‘å¾ˆæ¸…æ¥šçš„çŸ¥é“ï¼Œæˆ‘ç†è§£è¿™ä¸ªå£°éŸ³è¡¨è¾¾çš„ä¿¡æ¯ï¼Œä½†æ˜¯ä¸¥æ ¼æ¥è¯´æˆ‘å¹¶ä¸èƒ½è¯æ˜æˆ‘çœŸçš„ç†è§£äº†è¿™æ ·ä¸€ä¸ªä¿¡æ¯ã€‚æˆ‘å¯ä»¥è¯´å‡ºè¿™ä¸¤ä¸ªè‹±æ–‡è¯çš„ä¸­æ–‡æ„æ€ï¼Œæˆ‘ä¹Ÿå¯ä»¥è¯´å‡ºâ€hello worldâ€ è¿™ä¸¤ä¸ªè¯æ˜¯å¾ˆå¤šç¨‹åºå‘˜åœ¨å¼€å§‹å­¦ä¹ ç¼–ç¨‹è¯­è¨€æ—¶ä½¿ç”¨çš„æ‰“å°è¾“å‡ºæ–‡æœ¬ã€‚ç”šè‡³æˆ‘å¯ä»¥å¤§å¼€è„‘æ´ï¼Œå½“è¿™ä¸ªå£°éŸ³æ˜¯æŸä¸ªå…·æœ‰äººå·¥æ™ºèƒ½çš„ç”µè„‘ç¨‹åºå‘å‡ºçš„å¯¹è¿™ä¸ªä¸–ç•Œçš„é—®å€™ã€‚ä¸è¿‡å½’æ ¹åˆ°åº•æˆ‘å¹¶ä¸èƒ½è¯æ˜ï¼Œæˆ‘ç†è§£äº†è¿™ä¸ªè¯­è¨€ç‰‡æ®µã€‚ç†è§£è¿™ä¸ªè¯çš„æ¦‚å¿µæ˜¯æ¨¡ç³Šçš„ï¼Œè¿™ä¸ªé—®é¢˜ä¹Ÿæœ€ç»ˆæ²¦ä¸ºäº†ä¸€ä¸ªå½¢è€Œä¸Šçš„å“²å­¦é—®é¢˜ã€‚ äººç±»æ–‡æ˜å²å³è¯­è¨€å²ä»æ•´ä¸ªåœ°çƒçš„å†å²æ¥çœ‹ï¼Œäººç±»æœ¬èº«çš„æ–‡æ˜å‘å±•å²ï¼Œæ˜¯ä¸€ä¸ªæå…¶å°çš„æ—¶é—´ç‰‡æ®µã€‚è€Œäººç±»å¯¹äºè‡ªèº«æ–‡æ˜å²çš„è€ƒè¯ï¼Œæ¯«æ— ç–‘é—®æ˜¯å»ºç«‹åœ¨å¯¹å¤ä»£äººç±»å„ç§å†å²é—è¿¹ä¿¡æ¯ä¸Šçš„ã€‚åœ¨è¿™äº›ä¿¡æ¯å½“ä¸­ï¼Œå¤ä»£äººç•™ä¸‹çš„è¯­è¨€å’Œæ–‡å­—é—è¿¹ï¼Œåˆ™æ¯«æ— ç–‘é—®æ˜¯å¯¹äººç±»é«˜åº¦çš„æ–‡æ˜æœ€å¼ºæœ‰åŠ›çš„è¯æ˜ã€‚ æš‚ä¸”ä»¥å››å¤§æ–‡æ˜å¤å›½ä¸ºä¾‹ï¼Œå„è‡ªçš„å‘å±•è¿‡ç¨‹ä¸­ï¼Œéƒ½åˆ†åˆ«å­•è‚²é™¤äº†è‡ªå·±çš„è¯­è¨€å’Œæ–‡å­—ç³»ç»Ÿã€‚æ­£æ˜¯æœ‰äº†è¿™äº›æ–‡å­—ä¿¡æ¯æ‰å¾—ä»¥å°†å„è‡ªçš„å†å²å’Œæ•…äº‹è®°å½•ä¸‹æ¥ï¼Œå¹¶ä¼ æ‰¿ä¸‹æ¥ã€‚å°±åœ¨è¿™äº›è¯­è¨€å’Œæ–‡å­—çš„ä¼ æ‰¿è¿‡ç¨‹ä¸­ï¼Œè¯­è¨€æœ¬èº«ä¹Ÿéšç€å„ä¸ªæ–‡æ˜çš„å‘å±•ä¸æ–­çš„è°ƒæ•´å’Œè¿›åŒ–ï¼ŒåŒæ—¶åè¿‡æ¥æ¨åŠ¨äººç±»æ–‡æ˜çš„ç¤¾ä¼šç»“æ„çš„å‡çº§ã€‚äººä¸äººä¹‹é—´æ²Ÿé€šçš„æ•ˆç‡è¶Šæ¥è¶Šé«˜ï¼Œäººç±»ç¤¾ä¼šçš„åˆ†å·¥åˆä½œè¶Šå‘çš„å¼ºå¤§ã€‚ åœ¨è¿™é‡Œå¯ä»¥ä»¥ä¸­å›½ä½œä¸ºæ›´ä¸ºå…¸å‹çš„ä¾‹å­ï¼Œæ¥å¯¹æ•´ä¸ªä¸­åæ–‡æ˜çš„å‘å±•å†ç¨‹è¿›è¡Œä¸€ä¸ªç®€å•çš„å›é¡¾ã€‚ä¾‹å¦‚ï¼Œç”²éª¨æ–‡æ˜¯ä¸­å›½æ±‰å­—çš„å‘å±•è¿‡ç¨‹ä¸­ï¼Œå¯è€ƒçš„æœ€æ—©å‡ºç°çš„æˆç³»ç»Ÿçš„è¾ƒä¸ºæˆç†Ÿçš„æ±‰å­—ã€‚ç”²éª¨æ–‡ï¼Œåˆç§°â€œå¥‘æ–‡â€ã€â€œç”²éª¨åœè¾â€ã€æ®·å¢Ÿæ–‡å­—æˆ–â€œé¾Ÿç”²å…½éª¨æ–‡â€ã€‚ç”²éª¨æ–‡è®°å½•å’Œåæ˜ äº†å•†æœçš„æ”¿æ²»å’Œç»æµæƒ…å†µï¼Œä¸»è¦æŒ‡ä¸­å›½å•†æœåæœŸï¼ˆå‰14ï½å‰11ä¸–çºªï¼‰ç‹å®¤ç”¨äºå åœå‰å‡¶è®°äº‹è€Œåœ¨é¾Ÿç”²æˆ–å…½éª¨ä¸Šå¥‘åˆ»çš„æ–‡å­—ï¼Œå†…å®¹ä¸€èˆ¬æ˜¯å åœæ‰€é—®ä¹‹äº‹æˆ–è€…æ˜¯æ‰€å¾—ç»“æœã€‚æ®·å•†ç­äº¡å‘¨æœå…´èµ·ä¹‹åï¼Œç”²éª¨æ–‡è¿˜ä½¿ç”¨äº†ä¸€æ®µæ—¶æœŸï¼Œæ˜¯ç ”ç©¶å•†å‘¨æ—¶æœŸç¤¾ä¼šå†å²çš„é‡è¦èµ„æ–™ã€‚ç´§æ¥ç€ç”²éª¨æ–‡çš„é‡‘æ–‡å’ŒçŸ³é¼“æ–‡ï¼Œåœ¨ç»“æ„å’Œç³»ç»Ÿä¸Šå’Œç”²éª¨æ–‡æ˜¯ç±»ä¼¼çš„ï¼Œä½†æ˜¯å…¶æ–‡å­—æœ¬èº«è¿›åŒ–çš„æ›´ä¸ºæ ‡å‡†å’Œä¸¥è°¨ã€‚è¿™ä¸ªè¯­è¨€æ–‡å­—ä½“ç³»ä¸€ç›´æŒç»­åˆ°æ˜¥ç§‹æˆ˜å›½æ—¶æœŸï¼Œåœ¨å¤æ±‰è¯­ç ”ç©¶é¢†åŸŸå°†è¿™äº›æ–‡å­—ç»Ÿç§°ä¸ºâ€œå¤§ç¯†â€ã€‚ ç§¦æœç»Ÿä¸€å…­å›½ä¹‹åï¼Œæ‰å°†ä¹‹å‰æ··ä¹±çš„è¯­è¨€æ–‡å­—ä½“ç³»è¿›è¡Œäº†ç»Ÿä¸€ã€‚ç»è¿‡ç§¦å›½ä¸ç›¸ææ–¯çš„æ•´ç†ï¼Œæ±‰å­—è¢«ç»Ÿä¸€ä¸ºä¸€ç§é€šè¡Œä¹¦ä½“ã€‚è¿™ç§ä¹¦ä½“è¢«ç§°ä¹‹ä¸ºå°ç¯†ï¼ŒåŒæ—¶ä¹Ÿå¯ä»¥å«åšç§¦ç¯†ã€‚è¿™æ˜¯ä¸­å›½å¤ä»£æ–‡æ˜å‘å±•å†å²è¿‡ç¨‹ä¸­ä¸€ä¸ªé‡Œç¨‹ç¢‘å¼çš„æ ‡å¿—ã€‚ç¬¬ä¸€æ¬¡ï¼Œåœ¨ä¸­å›½çš„å¤§åœ°ä¸Šï¼ŒåŸå…ˆæ‰€æœ‰å›½å®¶çš„äººæ°‘ç°åœ¨ç»ˆäºå¯ä»¥ç”¨é€šç”¨çš„æ±‰å­—ç³»ç»Ÿè¿›è¡Œè¡¨è¾¾å’Œäº¤æµã€‚è¿™ä¸€ç‚¹æå¤§çš„ä¿ƒè¿›äº†ä¸­åæ–‡æ˜æœ¬èº«çš„å‘å±•ï¼Œç›´æ¥ä¿ƒè¿›äº†ä¸­å›½å¤ä»£ç»æµå’Œæ–‡åŒ–çš„å‘Šè¯‰å‘å±•ã€‚è¿™ä¸ªæ—¶æœŸï¼Œä¸­å›½å¤ä»£æ–‡æ˜åœ¨åˆ¶åº¦çš„ä½œç”¨ä¸‹ï¼Œåˆ©ç”¨è¯­è¨€çš„ç»Ÿä¸€ç›´æ¥æ¨åŠ¨äº†ä¸­å›½æ–‡æ˜çš„å‘å±•ã€‚ éšåä¸­å›½æ±‰å­—è¿æ¥äº†å‘å±•å†å²ä¸­æœ€é‡è¦çš„ä¸€ä¸ªäº‹ä»¶ï¼Œéš¶ä¹¦å‡ºç°äº†ã€‚ç›¸ä¼ éš¶ä¹¦çš„åˆ›å§‹äººæ˜¯ç¨‹é‚ˆï¼Œå› ä»–å¾—ç½ªäº†ç§¦å§‹çš‡ï¼Œä¸‹äº†ç›‘ç‹±ï¼Œåœ¨ç‹±ä¸­ç”¨äº†åå¹´çš„å·¥å¤«ï¼Œæ•´ç†å‡ºä¸€å¥—åº”ç”¨ç®€ä¾¿çš„æ–°å­—ä½“ï¼Œè¢«åäººç§°ä¸ºéš¶ä¹¦ã€‚åœ¨å°ç¯†ç»Ÿä¸€äº†æ–‡å­—å½¢å¼ä¹‹åï¼Œéš¶ä¹¦å°†åŸæ¥çš„å¤æ‚ç»Ÿä¸€å½¢å¼è¿›è¡Œäº†é«˜åº¦çš„ç®€åŒ–ï¼Œè¿™ä¸ªç®€å•åŒ–çš„æ€æƒ³åˆ™æ˜¯ç°ä»£æ±‰å­—å‘å±•è¿‡ç¨‹ä¸­æœ€é‡è¦çš„ä¸€ä¸ªæ€æƒ³ã€‚åˆ°äº†æ±‰ä»£ï¼Œéš¶ä¹¦é€æ¸æˆç†Ÿï¼Œå æ®äº†ä¸»è¦åœ°ä½ã€‚ éšç€å†å²çš„ç»§ç»­æ¨è¿›ï¼Œç»ˆäºåœ¨éš¶ä¹¦çš„åŸºç¡€ä¸Šï¼Œä¸­å›½æ–‡æ˜æ¼”åŒ–å‡ºäº†æ¥·ä¹¦è¿™ä¸€ä¸€ç›´å»¶ç»­åˆ°ä»Šå¤©çš„æ­£ä½“å­—ã€‚æ¥·ä¹¦æ˜¯æˆ‘å›½å°å»ºç¤¾ä¼šå—åŒ—é­åˆ°æ™‹å”æœ€ä¸ºæµè¡Œçš„ä¸€ç§ä¹¦ä½“ã€‚æ¥·ä¹¦ä¹Ÿå«æ­£æ¥·ã€çœŸä¹¦ã€æ­£ä¹¦ã€‚ä»ç¨‹é‚ˆåˆ›ç«‹çš„éš¶ä¹¦é€æ¸æ¼”å˜è€Œæ¥ï¼Œæ›´è¶‹ç®€åŒ–ï¼Œæ¨ªå¹³ç«–ç›´ã€‚ è€Œä¸­å›½å¤§é™†çš„æ±‰å­—ç³»ç»Ÿï¼Œä¹‹åè¿˜ç»å†è¿‡ä¸€æ¬¡å¤§çš„ç®€åŒ–è¿åŠ¨ï¼Œè¿™é‡Œçš„æ ¸å¿ƒæ€è·¯æ²¡æœ‰å˜ã€‚éƒ½æ˜¯åœ¨åŸæœ‰ç¹ä½“å­—çš„åŸºç¡€ä¸Šï¼Œå°†ä¸€äº›å¤æ‚çš„æ¯”åˆ’è¿›è¡Œç®€å†™ï¼Œç®€åŒ–äº†æ•´ä¸ªæ±‰å­—ç³»ç»Ÿã€‚å½“ç„¶ä¸–ç•Œä¸Šç°åœ¨è¿˜æœ‰ä¸€äº›åœ°åŒºåœ¨ä½¿ç”¨ç¹ä½“å­—ï¼Œä½†æ˜¯å¤§ä½“çš„æ–¹å‘ä¸Šæ˜¯æ²¡æœ‰é—®é¢˜çš„ï¼Œéƒ½æ˜¯å¯¹åŸæœ‰ä¹¦å†™æ–¹å¼çš„ç®€åŒ–ã€‚ åœ¨ä¸­å›½æ–‡æ˜å‘å±•çš„è¿™ä¸ªä¾‹å­ä¸­ï¼Œå¯ä»¥å¾ˆæ˜æ˜¾çš„çœ‹å‡ºï¼šéšç€ä¸­å›½å¤ä»£æ–‡æ˜ç¨‹åº¦è¶Šé«˜ï¼Œæ±‰å­—çš„ä¹¦å†™æ–¹å¼ä¸€ç›´åœ¨ä¸æ–­çš„ç®€åŒ–ï¼Œåœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­ç®€åŒ–åçš„è¯­è¨€ï¼Œæ¯ä¸€æ¬¡éƒ½å¯¹æ•´ä¸ªç¤¾ä¼šçš„ç»æµå’Œæ–‡åŒ–å‘å±•èµ·åˆ°äº†æå¤§çš„æ¨åŠ¨ä½œç”¨ã€‚æ–‡æ˜çš„è¿›æ­¥å’Œæ±‰å­—çš„ç®€åŒ–æ˜¯ä¸€ä¸ªæ­£ç›¸å…³çš„è¿‡ç¨‹ï¼Œå…·ä½“ç›¸äº’å½±å“çš„ç»†èŠ‚å¯èƒ½å¹¶ä¸æ˜¯ç‰¹åˆ«æ¸…æ¥šï¼Œä½†æ˜¯åœ¨å¤§è¶‹åŠ¿ä¸Šèƒ½æ˜æ˜¾çš„çœ‹å‡ºï¼Œæ–‡æ˜çš„å‘å±•å²å°±æ˜¯è¯¥æ–‡æ˜è¯­è¨€æ–‡å­—çš„å‘å±•å²ã€‚ äººçš„ä¸€ç”Ÿå³è¯­è¨€ç†è§£å’Œè¿ç”¨çš„ä¸€ç”Ÿåœ¨æˆ‘ä»¬æ¯ä¸€ä¸ªå‡ºç”Ÿçš„æ—¶å€™ï¼Œéƒ½æ˜¯æ²¡æœ‰ä½¿ç”¨è¯­è¨€èƒ½åŠ›çš„ï¼Œä½†æ˜¯æœ€åæˆ‘ä»¬éƒ½é•¿æˆäº†èƒ½ç†Ÿç»ƒä½¿ç”¨è¯­è¨€çš„æˆäººã€‚è¿™å…¶å®åˆæ˜¯ä¸€ä¸ªä¸æ¸…ä¸æ¥šçš„è¿‡ç¨‹ã€‚è™½ç„¶æ¯ä¸ªäººéƒ½èƒ½å­¦ä¼šè‡ªå·±çš„æ¯è¯­ï¼Œå¯æ˜¯ï¼Œåœ¨è¿™èƒŒåï¼Œæˆ‘ä»¬å¯¹äºè‡ªå·±å­¦ä¹ è¯­è¨€è¿™ä¸€ä¸ªäº‹æƒ…æœ¬èº«å¹¶æ²¡æœ‰è¶³å¤Ÿçš„äº†è§£ã€‚æˆ‘ä»¬è‡ªå·±çš„å¤§è„‘åœ¨æ•´ä¸ªè¯­è¨€å­¦ä¹ çš„è¿‡ç¨‹ä¸­åˆ°åº•èµ·åˆ°äº†ä»€ä¹ˆä½œç”¨ï¼Œä»¥åŠå…·ä½“æ˜¯å¦‚ä½•å‘æŒ¥ä½œç”¨çš„ï¼Œæˆ‘ä»¬è‡ªå·±å¹¶æ²¡æœ‰æ‰¾åˆ°æ˜ç¡®çš„ç­”æ¡ˆã€‚ å°æ—¶å€™ï¼Œæˆ‘ä»¬å’‹å‘¼ç€è¦åƒé¥­é¥­ï¼Œåœ¨æˆ‘ä»¬è¯´å‡ºè¿™æ ·çš„è¯­è¨€æ—¶ï¼Œå¤§å®¶å¹¶ä¸ä¼šè§‰å¾—å¥‡æ€ªã€‚åˆ°äº†æˆ‘ä»¬è¿›å…¥å­¦æ ¡ï¼Œæ¸æ¸çš„é•¿å¤§çš„æ—¶å€™ï¼Œå¦‚æœè¿˜è¯´è¿™æ ·è¯´ï¼Œé‚£ä¼°è®¡æ‰“æ­»æˆ‘ä»¬ä¹Ÿè¯´ä¸å‡ºæ¥ã€‚ç„¶åï¼Œæˆ‘ä»¬åœ¨ç»å†äº†ç¤¾ä¼šçš„ç§ç§ï¼Œåˆ°äº†è€Œç«‹ä¹‹å¹´çš„æ—¶å€™ï¼Œæœ‰å¹¸é‡åˆ°ä¸€ä¸ªéš¾å¾—çš„çŸ¥å·±ï¼Œä¸¤æ¯æµŠé…’ç›¸è§†è€Œç¬‘ï¼Œä¸€å¥â€œè¯·â€ï¼Œè¡¨è¾¾å‡ºçš„åˆæ˜¯é‚£ä¹ˆä¸°æ»¡çš„æƒ…ç»ªå’Œæ„Ÿæ¦‚ã€‚ è¿™é‡Œæˆ‘ä»¬å…¶å®æœ‰ä¸€ä¸ªç‰¹åˆ«å…·æœ‰ä»£è¡¨æ€§çš„ä¾‹å­ï¼Œèƒ½è®©æˆ‘ä»¬æ¸…æ™°çš„çœ‹åˆ°æˆ‘ä»¬è‡ªå·±çš„æˆé•¿å’Œè¯­è¨€ç†è§£å’Œä½¿ç”¨èƒ½åŠ›çš„å…³ç³»ã€‚ä¸çŸ¥ä½ æ˜¯å¦è¿˜èƒ½æƒ³èµ·ï¼Œåœ¨å°å­¦æ—¶ï¼Œè¯­æ–‡è€å¸ˆç»™æˆ‘ä»¬å¸ƒç½®çš„ä½œä¸šã€‚é‚£äº›ä¸€ç™¾å­—ï¼Œä¸¤ç™¾å­—çš„æ—¥è®°ï¼Œè¿˜æœ‰ä½œæ–‡ä½œä¸šï¼Ÿé‚£æ—¶çš„æˆ‘ä»¬ä¸€ä»¶ä»¶çš„è®°å½•ç€æˆ‘ä»¬è‡ªå·±ç”Ÿæ´»çš„æµæ°´è´¦ï¼Œè¯•ç€ç”¨æ¸…æ™°çš„ï¼Œå®Œæ•´è¿è´¯çš„è¯­è¨€è¡¨è¾¾å‡ºæ¥ï¼Œç„¶è€Œæˆ‘ç›¸ä¿¡åœ¨å¤§éƒ¨åˆ†äººçš„è®°å¿†ä¸­ï¼Œè¿™ä¹Ÿå¹¶ä¸æ˜¯ä¸€ä»¶éå¸¸å®¹æ˜“çš„äº‹æƒ…ã€‚ åˆ°äº†åˆä¸­ï¼Œæˆ‘ä»¬å¼€å§‹è®¤çœŸçš„ä¹¦å†™é‚£500å­—çš„æ–‡ç« ï¼Œç»ˆäºæˆ‘ä»¬å¯ä»¥æœ‰å®åŠ›åº”ä»˜è¿™å‡ ç™¾å­—çš„è¡¨è¾¾ä»»åŠ¡ã€‚è¿™ä¸ªæ—¶å€™ï¼Œæˆ‘ä»¬å†é‡æ–°æ‹¾èµ·å°å­¦æ—¶æˆ‘ä»¬è‡ªå·±å†™ä¸‹çš„æ–‡å­—ï¼Œä¹Ÿè®¸æˆ‘ä»¬ä¼šè¢«è‡ªå·±å½“å¹´æ‹™ç•¥çš„è¡¨è¿°æ„ŸåŠ¨çš„ä¸å¥½æ„æ€ã€‚ä½†æ˜¯è¿™ä¸ªæ—¶å€™ï¼Œå·²ç»åŸºæœ¬èƒ½å¤Ÿç†è§£æˆäººä¸–ç•Œä¸­çš„å¤§éƒ¨åˆ†è¯æ±‡å’Œè¡¨è¾¾å«ä¹‰äº†ã€‚ ç„¶åï¼Œåˆ°äº†é«˜ä¸­çš„æ—¶å€™ï¼Œè¿™è¯­è¨€çš„è¡¨è¿°èƒ½åŠ›ç”šè‡³ç¬¬ä¸€æ¬¡åœ¨æˆ‘ä»¬äººç”Ÿçš„è¿‡ç¨‹ä¸­èµ·åˆ°äº†å†³å®šæ€§çš„ä½œç”¨ã€‚é‚£é«˜è€ƒè¯­æ–‡æœ€åä½œæ–‡çš„å‡ ååˆ†ï¼Œä¹Ÿè®¸å°±æ˜¯åŒ—äº¬å¤§å­¦å’Œä¸€æ‰€æ™®é€š211ä¹‹é—´çš„å·®è·ï¼Œåˆæˆ–è€…ä¸€æœ¬å’ŒäºŒæœ¬ä¹‹é—´çš„å·®è·ã€‚è€Œä¸”æˆ‘ç›¸ä¿¡åˆ°äº†è¿™ä¸ªé˜¶æ®µï¼Œè¯­è¨€æœ¬èº«å¯¹äºæˆ‘ä»¬æ¥è¯´å·²ç»ä¸ä»…ä»…æ˜¯ç”¨æ¥è¯´äº‹çš„å·¥å…·äº†ã€‚ä¹Ÿè®¸ä½ å·²ç»é€å‡ºäº†ä½ äººç”Ÿçš„ç¬¬ä¸€å°æƒ…ä¹¦ï¼Œä¹Ÿè®¸ä½ åœ¨æ—¥è®°ä¸­å†™ä¸‹äº†ä½ çš„ç¬¬ä¸€æ¬¡å¤±æ‹ï¼Œç”šè‡³ä½ åœ¨è¯¾æœ¬çš„è§’è½å†™ä¸‹äº†é‚£ä¸ªä½ æ°¸è¿œä¸ä¼šå¿˜è®°çš„åå­—ã€‚ è®¨è®ºäººç”Ÿæ˜¯ä¸€ä¸ªæå…¶å¤æ‚çš„å‘½é¢˜ï¼Œä½†æ˜¯è¿™ä¸ªè¿‡ç¨‹ä¸­è¯­è¨€æ¯«æ— ç–‘é—®æˆä¸ºäº†ä¸€ä¸ªäººä¸ä¸–ç•Œæ²Ÿé€šçš„ä¸»è¦æ–¹å¼ã€‚æœ‰è¯—æ„ï¼Œäº¦æœ‰å¤±æ„ï¼Œæœ‰äº†å¿µæƒ³ï¼Œä¹Ÿæœ‰äº†ç«‹åœºã€‚ å¥è¯»ä¹‹ä¸çŸ¥ï¼Œæƒ‘ä¹‹ä¸è§£â€œå¥è¯»ä¹‹ä¸çŸ¥â€è¿™å¥è¯æ¥è‡ªäºéŸ©æ„ˆçš„ã€Šå¸ˆè¯´ã€‹ï¼ŒéŸ©æ„ˆè¿™ç¯‡æ–‡ç« è¯¦ç»†çš„é˜è¿°äº†è€å¸ˆåœ¨ä¸€ä¸ªäººçš„å­¦ä¹ ç”Ÿæ´»ä¸­çš„é‡è¦æ€§ã€‚è¿™å¥è¯ä¸­çš„â€œå¥è¯»â€ä¸€è¯æ˜¯è¡¨ç¤ºåœ¨å¤æ±‰è¯­å­¦ä¹ ä¸­çš„ä¸€ä¸ªå¾ˆé‡è¦çš„ç¯èŠ‚ï¼Œè¡¨ç¤ºå¥å­ä¸­ä¸åŒè¯è¯­ä¹‹é—´çš„åœé¡¿ã€‚ç”±äºåœ¨å¤ä»£ï¼Œæ±‰å­—ç³»ç»Ÿä¸­æ²¡æœ‰æ ‡ç‚¹ç¬¦å·çš„å­˜åœ¨ï¼Œå› æ­¤åœ¨å­¦ä¹ å‰äººæ–‡ç« çš„æ—¶å€™ï¼Œæ–­å¥å°±å˜å¾—éå¸¸é‡è¦ã€‚æœ‰ä¸€äº›æ—¶å€™ï¼Œæ–­å¥æ–¹å¼çš„ä¸åŒç›´æ¥å¯¼è‡´äº†ä¸€ä¸ªå¥å­å«ä¹‰è§£è¯»æˆäº†å®Œå…¨ä¸åŒçš„æ–¹å‘ã€‚å½“æ—¶çš„æƒ…å†µç³»ä¸‹ï¼Œå­¦ä¹ è¯­è¨€ï¼Œè‡³å°‘æ˜¯ä¹¦é¢è¯­è¨€æ˜¯ä¸€ä¸ªååˆ†ç¹é‡çš„å·¥ä½œã€‚å°½ç®¡æ–‡å­—å·²ç»ç»Ÿä¸€ï¼Œè€Œä¸”å•ä¸ªæ–‡å­—çš„ä¹¦å†™ç»è¿‡äº†ç³»ç»Ÿçš„ç®€åŒ–è¿‡ç¨‹ï¼Œä½†æ˜¯ç”±äºå¥è¯»è¿™ä¸ªé—®é¢˜çš„å­˜åœ¨ï¼Œæ‰€ä»¥éœ€è¦å¤§é‡çš„é˜…è¯»å’ŒèƒŒè¯µï¼Œä»¥ä¾¿äºé€šè¿‡ç»éªŒçš„ç§¯ç´¯é€æ­¥åŸ¹å…»å‡ºè‡ªå·±è¿›è¡Œå¥è¯»çš„èƒ½åŠ›ã€‚ å…¶å®ä¸ä»…ä»…æ˜¯å¤ä»£ï¼Œå³ä½¿æ˜¯åœ¨ä»Šå¤©ï¼Œåœ¨æ±‰è¯­è¯­æ–‡çš„å­¦ä¹ è¿‡ç¨‹ä¸­ï¼Œä¼¼ä¹å¾ˆå¤§ç¨‹åº¦ä¸Šå’Œå¤ä»£æ±‰è¯­çš„å­¦ä¹ æ–¹å¼æ²¡æœ‰ä»€ä¹ˆæ”¹å˜ã€‚é€šè¿‡å¤§é‡çš„é˜…è¯»ä¿¡æ¯çš„ç§¯ç´¯ï¼Œä»¥åŸ¹å…»å‡ºä¸€ç§è¿‘ä¹ç›´è§‰çš„å¯¹è¯­è¨€æœ¬èº«çš„æ„ŸçŸ¥ï¼Œå¹¶åœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­æŒæ¡å…¶ç”¨æ³•ã€‚ä»æœ¬è´¨ä¸Šæ¥è¯´ï¼Œæ— è®ºæˆ‘ä»¬æœ€åæ˜¯å¦çœŸçš„èƒ½å¤ŸæŒ‰ç…§é¢„æœŸçš„æ–¹å¼ï¼Œä½¿ç”¨è¯­è¨€è¿›è¡Œè¡¨è¾¾å’Œæ²Ÿé€šï¼Œå¾ˆå¤šæ—¶å€™æˆ‘ä»¬å¯¹è¯­è¨€æœ¬èº«å¹¶æ²¡æœ‰ä»€ä¹ˆäº†è§£ã€‚ä¹Ÿè®¸æ˜¯å› ä¸ºä¸­å›½çš„æ–‡å­—è¯­ä¹‰çš„æ¨¡ç³Šæ€§ï¼Œå¾ˆå¤šæ—¶å€™ï¼Œå¯¼è‡´æˆ‘ä»¬è‡ªå·±éƒ½ä¸çŸ¥é“æˆ‘ä»¬è‡ªå·±ç©¶ç«Ÿæ˜¯ä¸æ˜¯çœŸçš„ç†è§£äº†ä¸€ä¸ªè¯­è¨€ç‰‡æ®µã€‚ç›¸å½“ä¸€å¤§éƒ¨åˆ†çš„äººï¼Œåœ¨è¯´â€œæˆ‘æ‡‚äº†â€çš„æ—¶å€™ï¼Œç”šè‡³ä»…ä»…åªæ˜¯åœ¨è¡¨è¿°ï¼Œè¿™ä¸ªè¯­è¨€ç‰‡æ®µä¸­æ²¡æœ‰æˆ‘ä¸è®¤è¯†çš„å­—ç½¢äº†ã€‚ è€ƒè™‘åˆ°ä¸­å›½åœ¨æ°‘å›½ä¹‹å‰ï¼Œå‡ ä¹æ²¡æœ‰ç§‘å­¦çš„æ¦‚å¿µï¼Œæ›´ä¸ç”¨è¯´æˆç†Ÿçš„ç§‘å­¦ç ”ç©¶æ–¹æ³•ã€‚æˆ‘ä»¬å¯ä»¥è®¤ä¸ºï¼Œä¸­å›½è¯­è¨€å­¦çš„ç ”ç©¶ï¼Œæ˜¯åœ¨è¿›å…¥æ°‘å›½æ—¶æœŸä¹‹åçš„äº‹æƒ…ã€‚è¿™ä¸ªæ—¶æœŸï¼Œä¸­å›½æœ€æ—©çš„ä¸€æ‰¹è¯­è¨€å­¦ç ”ç©¶è€…ï¼Œé€šè¿‡å€Ÿé‰´è¥¿æ–¹çš„ç§‘å­¦ç ”ç©¶æ–¹æ³•ï¼Œå¼€å§‹å¯¹æ±‰è¯­è¿›è¡Œç ”ç©¶ã€‚ä¸è¿‡å› ä¸ºç‰¹æ®Šçš„å†å²æ—¶æœŸï¼Œè¿™ä¸ªæ—¶æœŸçš„è¯­è¨€å­¦å®¶é€šå¸¸ä¹Ÿæ˜¯å²å­¦å®¶ï¼Œå“²å­¦å®¶ã€‚é‚£æ˜¯ä¸€ä¸ªå¤§å¸ˆè¾ˆå‡ºçš„æ—¶ä»£ã€‚ è¿™é‡Œæˆ‘æƒ³ä»‹ç»ä¸¤ä¸ªå…¬è®¤çš„å¤§å¸ˆï¼ŒåŒæ—¶ä¹Ÿæ˜¯é‚£ä¸ªæ—¶ä»£å‡ ä¹å¼€å¤©è¾Ÿåœ°å¼çš„å¤§å®¶â€”â€”â€”â€”é™ˆå¯…æªå’Œèµµå…ƒä»»ã€‚ä¸‹é¢æ˜¯æ‘˜è‡ªç™¾åº¦ç™¾ç§‘çš„å¯¹ä¸¤ä½å¤§å¸ˆçš„ç®€ä»‹ï¼š é™ˆå¯…æªï¼ˆ1890.7.3â€”1969.10.7ï¼‰ï¼Œå­—é¹¤å¯¿ï¼Œæ±Ÿè¥¿ä¿®æ°´äººã€‚ä¸­å›½ç°ä»£æœ€è´Ÿç››åçš„é›†å†å²å­¦å®¶ã€å¤å…¸æ–‡å­¦ç ”ç©¶å®¶ã€è¯­è¨€å­¦å®¶ã€è¯—äººäºä¸€èº«çš„ç™¾å¹´éš¾è§çš„äººç‰©ï¼Œä¸å¶ä¼å­™ã€æ½˜å…‰æ—¦ã€æ¢…è´»ç¦ä¸€èµ·è¢«åˆ—ä¸ºæ¸…åå¤§å­¦ç™¾å¹´å†å²ä¸Šå››å¤§å“²äººï¼Œä¸å•æ€å‹‰ã€é™ˆå£ã€é’±ç©†å¹¶ç§°ä¸ºâ€œå‰è¾ˆå²å­¦å››å¤§å®¶â€ã€‚ èµµå…ƒä»»ï¼ˆ1892.11.3â€”1982.2.24ï¼‰ï¼Œæ±‰æ—ï¼Œå­—å®£ä»²ï¼Œåˆå­—å®œé‡ ï¼ŒåŸç±æ±Ÿè‹æ­¦è¿›ï¼ˆä»Šå¸¸å·ï¼‰ã€‚æ¸…æœè‘—åè¯—äººèµµç¿¼ï¼ˆç“¯åŒ—ï¼‰åäººã€‚å…‰ç»ªåå…«å¹´ï¼ˆ1892å¹´ï¼‰ç”Ÿäºå¤©æ´¥ã€‚ç°ä»£è‘—åå­¦è€…ã€è¯­è¨€å­¦å®¶ã€éŸ³ä¹å®¶ã€‚èµµå…ƒä»»æ˜¯ä¸­å›½ç°ä»£è¯­è¨€å­¦å…ˆé©±ï¼Œè¢«èª‰ä¸ºâ€œä¸­å›½ç°ä»£è¯­è¨€å­¦ä¹‹çˆ¶â€ï¼ŒåŒæ—¶ä¹Ÿæ˜¯ä¸­å›½ç°ä»£éŸ³ä¹å­¦ä¹‹å…ˆé©±ï¼Œâ€œä¸­å›½ç§‘å­¦ç¤¾â€çš„åˆ›å§‹äººä¹‹ä¸€ã€‚ é™ˆå¯…æªçš„æˆå°±è‡ªä¸ç”¨è¯´ï¼Œå…¶å­¦æœ¯å‡ºæˆå°±è¿œè¿œä¸åªæ˜¯åœ¨è¯­è¨€å­¦ä¸Šï¼Œå…¶å­¦æœ¯å·¥ä½œåœ¨ä¸­å›½è¿‘ä»£å‘å±•ä¸Šæœ‰ç€æå…¶é‡è¦çš„å½±å“ã€‚å…¶çˆ¶äº²é™ˆä¸‰ç«‹æ›´æ˜¯åœ¨é‚£ä¸ªå¹´ä»£è®¾ç«‹ç§äººå­¦å ‚ï¼Œå®Œå…¨é‡‡ç”¨ç°ä»£åŒ–çš„æ•™è‚²æ–¹å¼ï¼Œå­¦ä¹ è¯­è¨€ï¼Œå†å²ï¼ŒéŸ³ä¹ï¼Œå¤–è¯­ï¼Œæ•°å­¦ç­‰å­¦ç§‘ã€‚åœ¨è¿™æ ·çš„ç¯å¢ƒå½±å“ä¸‹ï¼Œé™ˆå¯…æªå¾ˆæ—©å°±æœ‰äº†è¥¿æ–¹ç°ä»£åŒ–ç§‘å­¦ç ”ç©¶çš„åŸºç¡€ï¼Œå°¤å…¶æ˜¯æ•°å­¦è¿™ç±»ç§‘å­¦ç†å·¥ç±»çš„è¯¾ç¨‹ã€‚ åæ¥å…¶åœ¨å›½å¤–ç•™å­¦18å¹´ï¼Œæ˜¯ç½•è§çš„è¯­è¨€å¤©æ‰ã€‚ä»–æ›¾åœ¨ç¾å›½å“ˆä½›å¤§å­¦éšå…°æ›¼æ•™æˆå­¦ä¹ æ¢µæ–‡ã€å·´åˆ©æ–‡ä¸¤å¹´ï¼Œåæ¥åˆå›åˆ°æŸæ—å¤§å­¦ç ”ç©¶é™¢ç ”ç©¶æ¢µæ–‡åŠå…¶ä»–ä¸œæ–¹å¤æ–‡å­—å­¦å››å¹´ã€‚å›å›½ä¹‹åï¼Œä»–åˆåœ¨åŒ—äº¬å’Œæ±‰å­¦å®¶é’¢å’Œæ³°æ•™æˆç»§ç»­ç ”ç©¶æ¢µæ–‡å››äº”å¹´ã€‚é™ˆå¯…æªä¸€ç”Ÿä¸­é€šæ™“çš„è¯­è¨€æœ‰äºŒä¸‰åç§ä¹‹å¤šã€‚è‹±æ–‡ã€æ³•æ–‡ã€å¾·æ–‡ã€ä¿„æ–‡ã€æ—¥æ–‡è‡ªä¸å¿…è¯´ï¼Œä»–è¿˜ç²¾é€šæ¢µæ–‡ã€å·´åˆ©æ–‡ã€æ»¡æ–‡ã€è’™æ–‡ã€çªå¥æ–‡ã€è¥¿å¤æ–‡ã€ä¸­å¤æ³¢æ–¯æ–‡ï¼Œè¿˜æœ‰æ‹‰ä¸æ–‡ã€é©¬æ‰å°”æ–‡ç­‰ç­‰ã€‚ èµµå…ƒä»»çš„æˆå°±åˆ™æ›´åŠ é›†ä¸­åœ¨è¯­è¨€å­¦ç ”ç©¶å’ŒéŸ³å¾‹ç›¸å…³çš„å·¥ä½œã€‚èµµå…ƒä»»æœ¬ç§‘åœ¨åº·å¥ˆå°”å¤§å­¦å­¦ä¹ æ•°å­¦ï¼Œé€‰ä¿®ç‰©ç†å’ŒéŸ³ä¹ï¼Œåæ¥åœ¨å“ˆä½›å¤§å­¦è·å¾—å“²å­¦åšå£«å­¦ä½ã€‚1925å¹´èµµå…ƒä»»å›æ¸…åå¤§å­¦æ•™æˆæ•°å­¦ã€ç‰©ç†å­¦ã€ä¸­å›½éŸ³éŸµå­¦ã€æ™®é€šè¯­è¨€å­¦ã€ä¸­å›½ç°ä»£æ–¹è¨€ã€ä¸­å›½ä¹è°±ä¹è°ƒå’Œè¥¿æ´‹éŸ³ä¹æ¬£èµç­‰è¯¾ç¨‹ã€‚ä»–ä¸æ¢å¯è¶…ã€ç‹å›½ç»´ã€é™ˆå¯…æªä¸€èµ·è¢«ç§°ä¸ºæ¸…åâ€œå››å¤§å¯¼å¸ˆâ€ã€‚ è™½ç„¶å‡ºèº«ä¸åŒï¼Œä½†æ˜¯èƒ½æ˜æ˜¾çœ‹å‡ºè¿™ä¸¤ä½å¤§å¸ˆåœ¨èƒŒæ™¯ä¸Šå¾ˆå¤šç›¸ä¼¼çš„åœ°æ–¹ã€‚ä¸¤äººéƒ½ç•™å­¦å¤šå¹´ï¼Œéƒ½æœ‰è¥¿æ–¹ç°ä»£ç§‘å­¦åŸºç¡€ç´ å…»ï¼Œéƒ½å¯¹è¯­è¨€æœ‰ç€è¿‘ä¹ä¸‡ä¸­æ— ä¸€çš„å¤©æ‰å’Œçƒ­æƒ…ã€‚è€Œä½œä¸ºä¸­å›½è¿‘ä»£è¯­è¨€å­¦ä¹‹çˆ¶çš„èµµå…ƒä»»æ›´æ˜¯å­¦ä¹ æ•°å­¦ä¸“ä¸šå‡ºèº«ï¼Œç‰©ç†å“²å­¦åšå£«ã€‚ç”±æ­¤ä¾¿å¯ä»¥çœ‹å‡ºï¼ŒçœŸæ­£çš„ç ”ç©¶ä¸ä»…ä»…æ˜¯èƒ½å¤Ÿè®°ä½å’ŒèƒŒä¸‹æ›´å¤šçš„å¤ç±å’Œå²æ–™ï¼Œè€Œæ˜¯å»ºç«‹åœ¨ç°ä»£ç§‘å­¦åŸºç¡€æ–¹æ³•ä¸Šè¿›è¡Œçš„æ¢ç´¢ã€‚è€Œä¸”æ®è¯´å½“å¹´è¿˜æ˜¯è¿‘ä»£å¤§å“²å­¦å®¶ï¼Œæ•°å­¦å®¶ç½—ç´ çš„å»ºè®®ï¼Œè®©èµµå…ƒä»»ä¸‹å®šäº†ä¸€ç”Ÿå°†è¯­è¨€å­¦ç ”ç©¶ä½œä¸ºäº‹ä¸šçš„å†³å¿ƒã€‚ æ‰€æœ‰çš„ç§‘å­¦ç ”ç©¶éƒ½åº”è¯¥æ˜¯å»ºç«‹åœ¨æ•°ç†é€»è¾‘çš„åŸºç¡€ä¹‹ä¸Šï¼Œè¯­è¨€ç ”ç©¶ä¹Ÿä¸ä¾‹å¤–ã€‚è¯­è¨€æœ¬èº«å°±æ˜¯å¯ä»¥è¢«ç ”ç©¶çš„ä¸€ç§äººç±»ç‰¹æœ‰çš„ç¤¾ä¼šç°è±¡ã€‚ è€Œæˆ‘å¾ˆæƒ­æ„§ï¼Œåœ¨å¤§å­¦ä¹‹åï¼Œå­¦ä¹ äº†ä¸­è¥¿æ–¹è¿‘ä»£å“²å­¦ï¼ŒåŒæ—¶æœ‰æœºä¼šå­¦ä¹ åŒ—å¤§èƒ¡å£®éºŸæ•™æˆçš„ã€Šè¯­è¨€å­¦æ•™ç¨‹ã€‹ä¹‹åï¼Œæ‰æ‰“å¼€äº†å¼‚ä¸–ç•Œçš„å¤§é—¨ã€‚åæ¥æˆ‘çŸ¥é“äº†ä¹”å§†æ–¯åŸºï¼ŒçŸ¥é“äº†0-3å‹æ–‡æ³•ã€‚çŸ¥é“äº†æ•°å­¦çš„é›†åˆè®ºå’Œè¯­è¨€å­¦åœ¨è¿™é‡Œè¾¾åˆ°äº†å½¢å¼ä¸Šçš„ç»Ÿä¸€ã€‚çŸ¥é“äº†è®¡ç®—è¯­è¨€å­¦å’Œè®¡ç®—æœºçš„å¼ºå¤§ã€‚éšåæ›´æ˜¯è¿½æœ¬æº¯æºçŸ¥é“äº†å›¾çµï¼ŒçŸ¥é“äº†å›¾çµå’Œä¸˜å¥‡å…³äºå¯è®¡ç®—æ•°çš„å·¥ä½œã€‚ åŸæ¥çœŸæ­£æ˜¯â€œæ–‡ç†ä¸åˆ†å®¶â€ï¼å”¯æœ‰å¯¹çœŸç†çš„è¿½æ±‚æ°¸æ’ä¸å˜ã€‚ ç‰›é¡¿çš„è‹¹æœæ•´ä¸ªäººç±»æ–‡æ˜çš„å‘å±•è¿‡ç¨‹åœ¨ç›¸å½“é•¿çš„ä¸€æ®µæ—¶é—´å†…æ˜¯æå…¶ç¼“æ…¢çš„ï¼Œä¸åŒæœä»£æ›´è¿­ï¼Œä½†æ˜¯ç¤¾ä¼šå½¢æ€å´å¹¶æ²¡æœ‰ä»€ä¹ˆæœ¬è´¨ä¸Šçš„å˜åŒ–ã€‚ä½†æ˜¯ç‰›é¡¿ç»å…¸åŠ›å­¦çš„å‡ºç°ï¼Œæ‰“ç ´äº†ä¸€åˆ‡æŒ‰éƒ¨å°±ç­ï¼ŒåŒæ—¶ä¹Ÿè®©æ•´ä¸ªè¥¿æ–¹ä¸–ç•Œåœ¨æçŸ­çš„æ—¶é—´å†…æŒæ¡äº†è¶³å¤Ÿçš„ç§‘å­¦æŠ€æœ¯å’Œå·¥ç¨‹èƒ½åŠ›ã€‚è€Œè¿™æœ€ç›´æ¥çš„åæœå°±æ˜¯ä¸­å›½è¿‘ä»£æ‰€é¢ä¸´çš„å±€é¢ï¼Œä¸€ä¸ªä¸ç¼ºèµ„æºä¸ç¼ºåƒç©¿çš„æ³±æ³±å¤§å›½å¿½ç„¶è¢«è¥¿æ–¹çš„è›®å¤·åè¶…ï¼Œå¹¶è¢«æ‘åœ¨åœ°ä¸Šä¸€é¡¿æš´æã€‚ å…³äºç‰›é¡¿çš„è‹¹æœå¯¹äºæ•´ä¸ªç§‘å­¦çš„å‘å±•å²ç©¶ç«Ÿæœ‰å¤šå¤§çš„å½±å“åŠ›ï¼Œæˆ‘ä»¬å¯ä»¥ä»è·¨åº¦æ›´å¤§çš„äººç±»ç§‘å­¦å‘å±•å²æ¥è¿›è¡Œè§‚å¯Ÿï¼š ç¬¬ä¸€ä¸ªå¤§çš„é˜¶æ®µï¼Œå¯ä»¥ä»äººç±»å‘å±•å‡ºç³»ç»Ÿçš„è¯­è¨€å’Œæ–‡å­—ä¸€ç›´åˆ°16ä¸–çºªä¹‹å‰ã€‚è¿™ä¸ªé˜¶æ®µï¼Œæ•´ä¸ªä¸–ç•Œçš„ç§‘å­¦å‘å±•æ°´å¹³æ˜¯å·®è·ä¸å¤§çš„ã€‚æ¯ä¸€ä¸ªç‹¬ç«‹çš„æ–‡æ˜ï¼Œéƒ½å‘å±•å‡ºäº†è‡ªå·±çš„è®¡æ•°ç³»ç»Ÿï¼Œç”šè‡³æ˜¯å¤©æ–‡ï¼Œåˆç­‰å‡ ä½•ï¼Œç‰©ç†ï¼Œå“²å­¦ç³»ç»Ÿã€‚åœ¨è¿™ä¸€ä¸ªé˜¶æ®µï¼Œå¯¹äºç§‘å­¦çš„æ¦‚å¿µï¼Œæ›´å¤šçš„æ˜¯ä¸€ç§å“²å­¦ä¸Šçš„æ€è€ƒï¼Œä¸€ç§å¯¹ç°è±¡èƒŒååŸç†çš„åæ€ã€‚å·¥ç¨‹åˆ™æ›´å¤šçš„æ˜¯ä¸€é—¨æ‰‹è‰ºï¼Œä¸€ç§åŸºäºå‰äººå·¥åŒ ç»éªŒçš„ç§¯ç´¯å’Œå®ç°ã€‚è¿™ä¸ªæ—¶æœŸï¼Œæ— è®ºä»è¥¿æ–¹çš„å†å²è¿˜æ˜¯ä¸­å›½å†å²ï¼Œéƒ½èƒ½æ‰¾åˆ°å¾ˆå¤šç¢ç‰‡å¼çš„å¯¹ä¸€äº›å…·ä½“é—®é¢˜çš„è¿›è¡Œç ”ç©¶çš„è‘—ä½œã€‚æ€»ä½“çš„æ¥è¯´ï¼Œè¿™ä¸ªé˜¶æ®µè™½ç„¶ä¹Ÿå‡ºç°äº†æ— æ•°çš„å¤§å¸ˆï¼Œä½†æ˜¯å¹¶æ²¡æœ‰å½¢æˆæˆç†Ÿæœ‰æ•ˆçš„ç§‘å­¦ç ”ç©¶ä½“ç³»ã€‚ ç¬¬äºŒä¸ªé˜¶æ®µï¼Œå‡ ä¹å°±æ˜¯ä»¥ç‰›é¡¿ä¸€ä¸ªäººä¹‹åŠ›æ‰“å¼€çš„å±€é¢ã€‚å½“ç„¶ï¼Œä¸¥æ ¼æ¥è¯´ï¼ŒåŒæ—¶æœŸçš„è±å¸ƒå°¼èŒ¨ç­‰å¤§å¸ˆä¹Ÿèµ·åˆ°äº†æå…¶é‡è¦çš„ä½œç”¨ã€‚1643å¹´çš„1æœˆï¼Œä¸€ä¸ªæ—©äº§å„¿å‡ºç”Ÿåœ¨è‹±å›½è‹±æ ¼å…°æ—è‚¯éƒ¡çš„å‘ä¸‹ï¼Œä½†æ˜¯è°ä¹Ÿæ²¡æƒ³åˆ°è¿™æ ·ä¸€ä¸ªå°æ—¶å€™è‹¥ä¸æƒŠé£ï¼Œçœ‹ä¸Šå»å¹³æ·¡æ— å¥‡çš„ä¸€ä¸ªæ—©äº§å„¿å´æˆä¸ºäº†è¥¿æ–¹ç§‘å­¦å‘å±•å²ä¸Šæœ€é‡è¦çš„äººç‰©ã€‚ç‰›é¡¿ä¸€ç”Ÿä¸­æœ€é‡è¦çš„å·¥ä½œæœ‰ä¸‰ä¸ªæå…¶çªå‡ºï¼š1.ç‰©ç†å­¦ä¸Šæå‡ºäº†ä¸‡æœ‰å¼•åŠ›å’Œç»å…¸çš„åŠ›å­¦ä¸‰å®šå¾‹ï¼Œæå‡ºäº†ç‰›é¡¿è¿åŠ¨å®šå¾‹ï¼Œå…‰å­¦ä¸Šå‘ç°äº†å…‰çš„å…‰è°±ç­‰ã€‚2.æ•°å­¦ä¸Šï¼Œå’Œè±å¸ƒå°¼èŒ¨åˆ†åˆ«ç‹¬ç«‹çš„å‘æ˜äº†æ•°å­¦ä¸Šæœ€é‡è¦çš„å·¥å…·â€”â€”â€”â€”å¾®ç§¯åˆ†ã€‚3.ç»æµå­¦ä¸Šï¼Œæå‡ºäº†åŸºäºé‡‘æœ¬ä½çš„ä¸–ç•Œç»æµä½“ç³»ã€‚æ­£æ˜¯è¿™äº›å¼€æ‹“æ€§çš„å·¥ä½œï¼Œå°†äººç±»æ–‡æ˜å‘å±•è¿‡ç¨‹ä¸­äººç±»æŠ½è±¡çš„æ¨¡å‹å’Œå®é™…çš„ç‰©ç†ç°å®ç´§ç´§åœ°è”ç³»åˆ°äº†ä¸€èµ·ã€‚ä¹Ÿæ­£å¼ç”±äºè¿™äº›ç†è®ºå·¥å…·çš„å‡ºç°ï¼Œäººç±»åœ¨å¯¹è‡ªç„¶ç°è±¡è¿›è¡Œæ¢ç´¢çš„æ—¶å€™ï¼Œæœ‰äº†å¼ºå¤§çš„å·¥å…·ã€‚è¿™äº›å·¥å…·ç›´æ¥ä½¿äººç±»æ‘†è„±äº†åœ¨ç ”ç©¶æŸäº›é—®é¢˜æ—¶ï¼Œé«˜åº¦ä¾èµ–äºæŸäº›ç‰¹å®šèŒä¸šå‰äººçš„æƒ…å†µã€‚è¥¿æ–¹å¼€å§‹åœ¨è¿™äº›æ€æ½®çš„å½±å“ä¸‹ï¼Œé€æ­¥çš„å‘å±•å‡ºæˆç†Ÿçš„ç§‘å­¦ç ”ç©¶ä½“ç³»ã€‚ä¹Ÿæ­£å¼åœ¨è¿™ä¸€æ®µæ—¶æœŸï¼Œä¸­å›½ä¼¼ä¹è¢«è¥¿æ–¹æ®‹å¿çš„ç”©åˆ°äº†åé¢ã€‚è¿™ä¸€æ—¶æœŸï¼Œä¸­å›½æ­£å¤„åœ¨æ˜æ¸…è¯¥æœæ¢ä»£çš„æ—¶æœŸï¼Œä¹Ÿæ­£å¼ä»è¿™é‡Œå¼€å§‹ï¼Œä¸€åˆ‡éƒ½ä¼¼ä¹éƒ½ä¸ä¸€æ ·äº†ã€‚ ç¬¬ä¸‰ä¸ªé˜¶æ®µï¼Œä¹Ÿå‡ ä¹åŒæ ·æ˜¯ç”±å¦ä¸€ä¸ªåˆ’æ—¶ä»£çš„å¤§å¸ˆä»¥ä¸€äººä¹‹åŠ›å¼•é¢†çš„ã€‚19ä¸–çºªä¸‹åŠå¶ï¼Œåº·æ‰˜å°”æå‡ºäº†è‘—åçš„é›†åˆè®ºã€‚ä¹‹å‰ç§‘å­¦é¢†åŸŸçš„å„ä¸ªåˆ†æ”¯å’Œé—®é¢˜ï¼Œåœ¨é›†åˆè®ºçš„ç³»ç»Ÿä¸‹å¾—åˆ°äº†é«˜åº¦çš„ç»Ÿä¸€ã€‚ç°ä»£æ•°å­¦æœ¬èº«çš„ä¸¥æ ¼åŸºç¡€ï¼Œå°±æ˜¯å»ºç«‹åœ¨é›†åˆè®ºçš„ç†è®ºæ¡†æ¶ä¹‹ä¸Šçš„ã€‚éšç€å†å²çš„æ¨è¿›å’Œå‘å±•ï¼Œé›†åˆè®ºæˆä¸ºäº†å‡ ä¹æ•´ä¸ªç§‘å­¦çš„åŸºç¡€ï¼Œç©¶å…¶åŸå› æˆ‘ä¸ªäººè®¤ä¸ºå°±æ˜¯é›†åˆè®ºæœ¬è´¨ä¸Šå°±æ˜¯äººç±»æŠ½è±¡æ€ç»´çš„å®é™…ä½“ç°ã€‚ç”šè‡³äºé›†åˆè®ºç›®å‰å­˜åœ¨çš„é—®é¢˜ï¼Œä¹Ÿä¼¼ä¹æ˜¯äººç±»è‡ªèº«æ€ç»´èƒ½åŠ›çš„é™åˆ¶ã€‚å°±åƒ1931å¹´ï¼Œè‘—åçš„é€»è¾‘å­¦å®¶å“¥å¾·å°”æå‡ºçš„å“¥å¾·å°”ä¸å®Œå¤‡å®šç†ï¼Œç›´æ¥ä½¿æ•°å­¦çš„åŸºç¡€ç ”ç©¶å‘ç”Ÿäº†å‡ ä¹æ˜¯æ‘§æ¯æ‹‰æœ½å¼çš„å˜åŒ–ã€‚ ä»ä¸Šé¢äººç±»ç§‘å­¦å‘å±•çš„ä¸‰ä¸ªé‡è¦é˜¶æ®µå°±å¯ä»¥çœ‹å‡ºï¼Œæ— è®ºæ˜¯ç¬¬äºŒé˜¶æ®µè¿˜æ˜¯ç¬¬ä¸‰é˜¶æ®µéƒ½å¯¹äººç±»æ•´ä¸ªç§‘å­¦å‘å±•å²æ˜¯è½¬æŠ˜æ€§çš„é‡è¦å…³é”®ç‚¹ã€‚å°¤å…¶æ˜¯ç¬¬äºŒé˜¶æ®µçš„ç‰›é¡¿ï¼Œæ›´æ˜¯å¦‚æœ‰ç¥åŠ©ä¸€èˆ¬ï¼Œç»™æ•´ä¸ªäººç±»å¸¦æ¥äº†ç¥ä¹‹è§†è§’ã€‚æ­£æ˜¯å¸¦æ¥çš„ç¥ä¹‹è§†è§’ï¼Œä½¿æˆ‘ä»¬æœ‰äº†åŸºç¡€çš„ç†è®ºå·¥å…·ï¼Œå¯ä»¥æ¥ç›´æ¥å¯¹æˆ‘ä»¬å‘¨å›´çš„ä¸€åˆ‡è‡ªç„¶ç°è±¡å’Œç¤¾ä¼šç°è±¡è¿›è¡Œç ”ç©¶ï¼ŒåŒ…æ‹¬å¯¹è¯­è¨€çš„ç ”ç©¶ã€‚å½“ç„¶ï¼Œåœ¨å¯¹è¯­è¨€ç»†åˆ†é¢†åŸŸçš„ç ”ç©¶å†ç¨‹ä¸­ï¼Œä¹Ÿæœ‰è¿™æ ·çš„å¼€å¤©è¾Ÿåœ°çš„å¤§å¸ˆï¼Œç”šè‡³è€Œè¿™äº›å¤§å¸ˆç»™æˆ‘ä»¬çš„ç”Ÿæ´»å¸¦æ¥çš„å‘å±•é€Ÿåº¦ä¹‹å¿«ï¼Œè¿œè¿œè¶…è¿‡æˆ‘ä»¬è‡ªå·±çš„æƒ³æƒ³ã€‚å…¶ä¸­è¿™ä¸ªé¢†åŸŸç ”ç©¶æœ€é‡è¦çš„ä¸€äº›äººï¼Œç°åœ¨ä¾ç„¶å’Œæˆ‘æ´»åœ¨åŒä¸€ä¸ªä¸–ç•Œã€‚æˆ‘å‘è‡ªå†…å¿ƒçš„æ„Ÿåˆ°å…´å¥‹ï¼Œèƒ½å¤Ÿè§è¯è¿™ä¸€åˆ‡ï¼Œç”šè‡³å‚ä¸è¿™ä¸ªè¿‡ç¨‹å½“ä¸­ã€‚ ä¸Šé¢æ‰€æè¿°çš„æ•´ä¸ªç§‘å­¦å‘å±•çš„å†ç¨‹å’Œäº§ç”Ÿçš„äººç±»æ™ºæ…§çš„æˆæœï¼Œæ˜¯ç°ä»£ä¸€åˆ‡ç§‘å­¦ç ”ç©¶çš„åŸºç¡€ã€‚åœ¨è¿™è¿™æ ·çš„ä¸€ä¸ªèƒŒæ™¯ä¸‹ï¼Œæˆ‘ä»¬å°±å¯ä»¥å¾ˆæ¸…æ™°çš„çœ‹åˆ°ï¼šåœ¨ç ”ç©¶è¯­è¨€ç°è±¡çš„æ—¶å€™ï¼Œä¹Ÿæ˜¯å»ºç«‹åœ¨è¿™ä¸ªåŸºç¡€ä¹‹ä¸Šçš„ã€‚å¦‚æœä»…ä»…åªæ˜¯å»ºç«‹åœ¨ä¸ªäººç»éªŒä¸Šçš„æ¨¡æ£±ä¸¤å¯çš„â€œæˆ‘è®¤ä¸ºâ€ï¼Œåˆ™å®Œå…¨å’Œç¬¬ä¸€é˜¶æ®µçš„æ—¶å€™ï¼Œæ²¡æœ‰ä»€ä¹ˆæœ¬è´¨ä¸Šçš„åŒºåˆ«ã€‚ è¯´åˆ°è¿™é‡Œï¼Œæˆ‘ä»¬å¯ä»¥å¤§æ¦‚çš„çœ‹å‡ºï¼Œåœ¨é¢å¯¹è¿™æˆ‘ä»¬äººç±»è‡ªå·±çš„è¯­è¨€ç°è±¡æ—¶ï¼Œæˆ‘ä»¬åº”è¯¥é‡‡å–çš„æ€åº¦äº†ã€‚é«˜åº¦æˆç†Ÿçš„æŠ½è±¡åŒ–è¯­è¨€ç³»ç»Ÿæœ¬èº«æ˜¯ä¸€ç§åœ¨äººç±»ç¤¾ä¼šå­˜åœ¨ç‰¹æœ‰ç°è±¡ï¼Œè¯¥ç°è±¡çš„å‡ºç°ä¸äººç±»å†å²æ–‡æ˜çš„å»¶ç»­ï¼Œäººç±»ç”Ÿç†ä¸Šå¤§è„‘ç»“æ„ï¼Œäººç±»ç¤¾ä¼šçš„æ•™è‚²ç³»ç»Ÿï¼Œäººç±»è®¤çŸ¥çš„æœ¬è´¨æœ‰ç€é‡è¦çš„è”ç³»ã€‚è€Œæˆ‘ä¸ªäººè®¤ä¸ºï¼Œå¯¹äºè¯­è¨€ç°è±¡çš„æ·±å…¥ç ”ç©¶ï¼Œæœ¬è´¨ä¸Šå°±æ˜¯å¯¹äººç±»æ™ºèƒ½çš„ç ”ç©¶ï¼Œå°±æ˜¯å¯¹â€œæˆ‘æ˜¯è°â€è¿™æ ·ä¸€ä¸ªè¿™å“²å­¦ç»ˆæä¹‹é—®çš„æ¢ç´¢è¿‡ç¨‹ã€‚ç”šè‡³æœ‰å¯èƒ½è¶…è¶Šæˆ‘ä»¬äººç±»æœ¬èº«ï¼Œæ¢ç´¢æ™ºæœ¬è´¨çš„ä¸€ä¸ªè¿‡ç¨‹ã€‚ ä¸Šå¸è¯´ï¼Œè¦æœ‰å…‰ï¼Œäºæ˜¯ä¾¿æœ‰äº†å…‰ã€‚æˆ‘ä»¬ç°åœ¨æ˜¯ä¸æ˜¯ä¹Ÿè¦æˆä¸ºé€ ç‰©ä¸»äº†å‘¢ï¼Ÿ"},{"title":"AI that has Values","date":"2016-10-14T15:00:00.000Z","url":"/2016/10/14/2016-10-15-Translation-AI-values/","tags":[["Translation","/tags/Translation/"]],"categories":[["Translation","/categories/Translation/"]],"content":"è®©äººå·¥æ™ºèƒ½å®Œç¾è¿è¡Œï¼šæˆ‘ä»¬æ€ä¹ˆç»™äººå·¥æ™ºèƒ½ç³»ç»Ÿèµ‹äºˆä»·å€¼è§‚ï¼Ÿ Keeping AI Well Behaved:How Do We Engineer An Artificial System That Has Values? In Brief æ‘˜è¦ï¼š It is estimated that some 10 million self-driving cars will be on the road by the close of 2020, which raises questions about how an AI will respond in lethal situations.é¢„è®¡åˆ°2020å¹´ä¸ºæ­¢ï¼Œå…¨çƒå°†ä¼šæœ‰è¶…è¿‡100ä¸‡è¾†äººå·¥æ™ºèƒ½é©±åŠ¨çš„æ— äººè½¦ä¸Šè·¯ï¼ŒåŒæ—¶ä¹Ÿå¼•å‡ºäº†äººå·¥æ™ºèƒ½åœ¨å‘ç”Ÿè‡´å‘½äº‹æ•…æ—¶ä¼šæ€æ ·ååº”çš„é—®é¢˜ã€‚ In this exclusive interview, FLI researcher David Parkes discusses his work to engineer a value-aligned AI system.åœ¨è¿™ç¯‡ä¸“è®¿ä¸­ï¼ŒFLIçš„ç ”ç©¶å‘˜å¤§å«.å¸•å‰æ–¯è®¨è®ºäº†ä»–æ„å»ºå¸¦æœ‰ä»·å€¼è§‚çš„äººå·¥æ™ºèƒ½ç³»ç»Ÿçš„ä¸€äº›å·¥ä½œã€‚ Teaching AI to make Decisionsæ•™äººå·¥æ™ºèƒ½è¿›è¡Œè®¨è®º Imagine youâ€™re sitting in a self-driving car thatâ€™s about to make a left turn into on-coming traffic. One small AI system in the car will be responsible for making the vehicle turn, one system might speed it up or hit the brakes, other systems will have sensors that detect obstacles, and yet another system may be in communication with other vehicles on the road. Each system has its own goals â€” starting or stopping, turning or traveling straight, recognizing potential problems, etc. â€” but they also have to all work together toward one common goal: turning into traffic without causing an accident.æƒ³è±¡ä¸€ä¸‹ä½ æ­£ååœ¨ä¸€è¾†è‡ªæˆ‘é©±åŠ¨çš„æ— äººè½¦ä¸­ï¼Œå³å°†å·¦è½¬é¢å¯¹è¿é¢è€Œæ¥çš„è½¦æµã€‚è½¦å†…çš„äººå·¥æ™ºèƒ½ç³»ç»Ÿå°†ä¼šè´Ÿè´£æ§åˆ¶è½¬å‘çš„è¿‡ç¨‹ï¼Œä¸€ä¸ªç³»ç»Ÿä¹Ÿè®¸ä¼šåŠ é€Ÿæˆ–è€…æ˜¯åˆ¹è½¦ï¼Œå¦ä¸€äº›ç³»ç»Ÿå°†ä¼šé€šè¿‡ä¼ æ„Ÿå™¨æ¢æµ‹éšœç¢ç‰©ï¼Œè¿˜æœ‰ä¸€äº›ç³»ç»Ÿä¹Ÿè®¸ä¼šå’Œè·¯ä¸Šçš„å…¶ä»–è½¦è¾†è¿›è¡Œé€šä¿¡ã€‚æ¯ä¸€ä¸ªç³»ç»Ÿéƒ½æœ‰å…¶è‡ªå·±çš„ç›®æ ‡ â€” å¯åŠ¨æˆ–è€…åœæ­¢ï¼Œè½¬å‘æˆ–è€…ç›´æ¥è¡Œé©¶ï¼Œåˆ†è¾¨å‡ºæ½œåœ¨çš„é—®é¢˜ç­‰ç­‰ã€‚â€” ä½†æ˜¯ä»–ä»¬éƒ½éœ€è¦è¢«æ•´åˆåˆ°ä¸€èµ·æœå‘åŒä¸€ä¸ªç›®æ ‡ï¼šåœ¨ä¸å‘ç”Ÿäº‹æ•…çš„æƒ…å†µä¸‹è½¬æ¢ä¸ºæ­£å¸¸çš„äº¤é€šã€‚ Harvard professor and Future of Life researcher, David Parkes, is trying to solve just this type of problem. Parkes told FLI, â€œThe particular question Iâ€™m asking is: If we have a system of AIs, how can we construct rewards for individual AIs, such that the combined system is well behaved?â€å“ˆä½›æ•™æˆï¼Œæœªæ¥ç”Ÿæ´»ç ”ç©¶å‘˜ï¼Œå¤§å«.å¸•å‰æ–¯ï¼Œæ­£åœ¨è¯•å›¾è§£å†³è¿™ä¸€ç±»å‹çš„é—®é¢˜ã€‚å¸•å‰æ–¯å‘Šè¯‰FLIï¼Œâ€œå®é™…ä¸Šæˆ‘æ­£è¦è§£å†³çš„é—®é¢˜æ˜¯ï¼šå¦‚æœæˆ‘ä»¬æœ‰ä¸€ä¸ªäººå·¥æ™ºèƒ½ç³»ç»Ÿï¼Œæˆ‘ä»¬å¦‚ä½•æ‰èƒ½ä¸ºå…¶ä¸­æ¯ä¸€ä¸ªç‹¬ç«‹çš„ç³»ç»Ÿæ„å»ºå¥–åŠ±æ¨¡å¼ï¼Œä»¥ä¾¿äºæ•´åˆçš„ç³»ç»Ÿå¯ä»¥å®Œç¾çš„è¿è¡Œï¼Ÿâ€ Essentially, an AI within a system of AIsâ€”like that in the car example aboveâ€”needs to learn how to meet its own objective, as well as how to compromise so that itâ€™s actions will help satisfy the group objective. On top of that, the system of AIs needs to consider the preferences of society. For example, it needs to determine if the safety of the passenger in the car or a pedestrian in the crosswalk is a higher priority than turning left.å°¤å…¶æ˜¯ï¼Œä¸€ä¸ªäººåŒ…å«å¾ˆå¤šå­ç³»ç»Ÿçš„å·¥æ™ºèƒ½ç³»ç»Ÿ â€” æ¯”å¦‚ä¸Šé¢æ— äººè½¦çš„ä¾‹å­ä¸­è¯´çš„ â€” éœ€è¦å­¦ä¼šæ€æ ·æ‰èƒ½å®Œæˆè‡ªå·±çš„ç›®æ ‡ï¼ŒåŒæ—¶è¿˜è¦å­¦ä¼šå¦¥åä»¥ä¾¿äºå…¶å­ç³»ç»Ÿçš„è¡Œä¸ºèƒ½å¯¹å®Œæˆå®è§‚çš„ç›®æ ‡æä¾›å¸®åŠ©ã€‚åœ¨è¿™äº›é—®é¢˜ä¹‹ä¸Šï¼ŒåŒ…å«å¤šä¸ªå­ç³»ç»Ÿçš„äººå·¥æ™ºèƒ½éœ€è¦å°†ç¤¾ä¼šçš„ä»·å€¼åå¥½è€ƒè™‘è¿›æ¥ã€‚æ¯”å¦‚ï¼Œå½“å…¶éœ€è¦å†³å®šåœ¨è½¬å¼¯çš„è¿‡ç¨‹ä¸­ç©¶ç«Ÿæ˜¯è½¦å†…ä¹˜å®¢çš„å®‰å…¨æ›´ä¸ºé‡è¦è¿˜æ˜¯äººè¡Œé“ä¸Šè¡Œäººçš„å®‰å…¨æ›´é‡è¦ã€‚ Because environments like a busy street are so complicated, an engineer canâ€™t just program an AI to act in some way to always achieve its objectives. AIs need to learn proper behavior based on a rewards system. â€œEach AI has a reward for its action and the action of the other AI,â€ Parkes explained. With the world constantly changing, the rewards have to evolve, and the AIs need to keep up not only with how their own goals change, but also with the evolving objectives of the system as a whole.å› ä¸ºåƒå¿™ç¢Œçš„è¡—é“è¿™æ ·çš„ç¯å¢ƒå¤ªå¤æ‚ï¼Œå·¥ç¨‹å¸ˆæ— æ³•é€šè¿‡ç®€å•çš„ç¼–ç¨‹å‘Šè¯‰äººå·¥æ™ºèƒ½å»å¦‚ä½•é€šè¿‡æŸç§ç‰¹å®šçš„è¡Œä¸ºæ¨¡å¼å»ååº”ï¼ŒåŒæ—¶åˆæ€»èƒ½å®Œæˆå…¶ç›®æ ‡ã€‚äººå·¥æ™ºèƒ½éœ€è¦é€šè¿‡åŸºäºå¥–åŠ±çš„ç³»ç»Ÿå»å­¦ä¹ åˆé€‚çš„è¡Œä¸ºã€‚â€œæ¯ä¸€ä¸ªäººå·¥æ™ºèƒ½çš„è¡Œä¸ºéƒ½æœ‰è‡ªå·±çš„æ¿€åŠ±æ¨¡å¼ï¼ŒåŒæ—¶å…¶ä»–ç³»ç»Ÿä¹Ÿæœ‰ã€‚â€ Making an Evolving AIæ„å»ºä¸€ä¸ªè‡ªæˆ‘è¿›åŒ–çš„æ™ºèƒ½ç³»ç»Ÿ The idea of a rewards-based learning system is something most people can likely relate to. Who doesnâ€™t remember the excitement of a gold star or a smiley face on a test? And any dog owner has experienced how much more likely their pet is to perform a trick when it realizes it will get a treat. A reward for an AI is similar.åŸºäºå¥–åŠ±çš„å­¦ä¹ ç³»ç»Ÿçš„æƒ³æ³•å…¶å®ä¹Ÿå’Œå¤§å¤šæ•°äººçš„ç»å†ç›¸å…³ã€‚è°ä¸è®°å¾—åœ¨è€ƒè¯•ä¹‹åå¾—åˆ°é‡‘è‰²å°æ˜Ÿæ˜Ÿæˆ–è€…ä¸€ä¸ªç¬‘è„¸æ—¶çš„å…´å¥‹å‘¢ï¼Ÿè€Œä¸”æ¯ä¸€ä¸ªæœ‰å® ç‰©ç‹—çš„ä¸»äººéƒ½æœ‰è¿™æ ·çš„ç»éªŒï¼šå½“å® ç‰©ç‹—å‘ç°æŸç§è¡Œä¸ºå¯ä»¥è·å¾—å¥–åŠ±çš„æ—¶å€™ï¼Œå®ƒä»¬æ˜¯å¤šä¹ˆæ„¿æ„æ‰§è¡ŒæŸç§ç‰¹å®šçš„è¡Œä¸ºã€‚å¯¹äºäººå·¥æ™ºèƒ½çš„å¥–åŠ±ä¹Ÿæ˜¯ç±»ä¼¼çš„é“ç†ã€‚ A technique often used in designing artificial intelligence is reinforcement learning. With reinforcement learning, when the AI takes some action, it receives either positive or negative feedback. And it then tries to optimize its actions to receive more positive rewards. However, the reward canâ€™t just be programmed into the AI. The AI has to interact with its environment to learn which actions will be considered good, bad, or neutral. Again, the idea is similar to a dog learning that tricks can earn it treats or praise, but misbehaving could result in punishment.åœ¨è®¾è®¡äººå·¥æ™ºèƒ½ç³»ç»Ÿçš„æ—¶å€™æœ‰ä¸€ç§å¸¸ç”¨çš„æŠ€æœ¯ â€” å¼ºåŒ–å­¦ä¹ ã€‚åœ¨å¼ºåŒ–å­¦ä¹ çš„ä½œç”¨ä¸‹ï¼Œå½“äººå·¥æ™ºèƒ½é‡‡å–è¡ŒåŠ¨çš„æ—¶å€™ï¼Œå…¶ä¼šè·å¾—ç§¯æçš„æˆ–è€…æ¶ˆæçš„åé¦ˆã€‚è€Œä¸”å…¶éšåå°±ä¼šé€šè¿‡æœ€ä¼˜åŒ–å…¶è¡Œä¸ºå»è·å¾—æ›´ä¸ºç§¯æçš„å¥–åŠ±ã€‚ç„¶è€Œï¼Œè¿™å¥–åŠ±ä¸èƒ½ç›´æ¥è¢«ç¼–ç¨‹åˆ°AIçš„ç³»ç»Ÿä¸­ã€‚è¿™äº›äººå·¥æ™ºèƒ½å¿…é¡»è¦å’Œå‘¨å›´çš„ç¯å¢ƒè¿›è¡Œäº’åŠ¨ï¼Œå»å­¦ä¹ å“ªäº›è¡Œä¸ºè¢«è®¤ä¸ºæ˜¯å¥½çš„ï¼Œåçš„æˆ–è€…ä¸­æ€§çš„ã€‚åŒæ ·ï¼Œè¿™ä¸ªæƒ³æ³•å’Œè®­ç»ƒå® ç‰©ç‹—çš„è¿‡ç¨‹ç±»ä¼¼ï¼šæ‰§è¡ŒæŸç§è¡Œä¸ºè·å¾—å¥–åŠ±æˆ–è€…èµç¾ï¼Œåšé”™äº†åˆ™å¯èƒ½ä¼šå¼•å‘æƒ©ç½šã€‚ More than this, Parkes wants to understand how to distribute rewards to subcomponents (the individual AIs) in order to achieve good system-wide behavior. How often should there be positive (or negative) reinforcement, and in reaction to which types of actions?ä¸ä»…å¦‚æ­¤ï¼Œå¸•å‰æ–¯æƒ³è¦ç†è§£å¦‚ä½•é€šè¿‡å°†å¥–åŠ±åˆ†å‘ç»™å­ç³»ç»Ÿï¼ˆç‹¬ç«‹çš„äººå·¥æ™ºèƒ½ï¼‰ä»¥ä¾¿äºèƒ½å¤Ÿäº§ç”Ÿç³»ç»Ÿå±‚é¢çš„åˆç†è¡Œä¸ºã€‚æ­£å‘å¼ºåŒ–æˆ–è€…è´Ÿå‘å¼ºåŒ–çš„é¢‘ç‡è¦æ€ä¹ˆæ§åˆ¶ï¼Œè€Œä¸”åº”è¯¥åŸºäºå“ªç§è¡Œä¸ºå»å¼ºåŒ–å‘¢ï¼Ÿ For example, if you were to play a video game without any points or lives or levels or other indicators of success or failure, you might run around the world killing or fighting aliens and monsters, and you might eventually beat the game, but you wouldnâ€™t know which specific actions led you to win. Instead, games are designed to provide regular feedback and reinforcement so that you know when you make progress and what steps you need to take next. To train an AI, Parkes has to determine which smaller actions will merit feedback so that the AI can move toward a larger, overarching goal.ä¾‹å¦‚ï¼Œå¦‚æœä½ æ­£åœ¨ç©ä¸€æ¬¾è§†é¢‘æ¸¸æˆï¼Œä½†æ˜¯æ²¡æœ‰åˆ†æ•°ï¼Œæ²¡æœ‰å‘½æ•°é™åˆ¶æˆ–è€…å…¶ä»–çš„æˆåŠŸæˆ–è€…å¤±è´¥çš„æç¤ºï¼Œä½ ä¹Ÿè®¸ä¼šæ»¡ä¸–ç•Œè·‘æ‰“å¤–æ˜Ÿäººï¼Œæ€æ€ªç©ï¼Œä¹Ÿè®¸æœ€åæ¸¸æˆè¢«ä½ é€šå…³äº†ï¼Œä½†æ˜¯ä½ ä¸çŸ¥é“å…·ä½“ä»€ä¹ˆæ ·çš„è¡Œä¸ºå¯ä»¥è®©ä½ è·å¾—èƒœåˆ©ã€‚ç›¸åï¼Œæ¸¸æˆé€šå¸¸è¢«è®¾è®¡æˆé¢‘ç¹çš„è¿›è¡Œåé¦ˆå’Œå¼ºåŒ–ï¼Œè¿™æ ·ä½ å¯ä»¥çŸ¥é“ï¼Œä½ æ­£åœ¨è·å¾—ä¸€å®šçš„è¿›å±•è€Œä¸”ä½ çŸ¥é“ä¸‹ä¸€æ­¥ä½ è¦åšä»€ä¹ˆã€‚ä¸ºäº†è®­ç»ƒä¸€ä¸ªäººå·¥æ™ºèƒ½ç³»ç»Ÿï¼Œå¸•å‰æ–¯å¿…é¡»å†³å®šå“ªäº›å°çš„è¡Œä¸ºä¼šäº§ç”Ÿåé¦ˆä»¥è‡³äºäººå·¥æ™ºèƒ½èƒ½å¤Ÿæœå‘æ›´åŠ å®è§‚çš„ç›®æ ‡ã€‚ But this is all for just one AI. How do these techniques apply to two or more AIs?ä½†æ˜¯è¿™åªæ˜¯å¯¹äºå•ä¸ªäººå·¥æ™ºèƒ½è€Œè¨€ã€‚è¿™äº›æŠ€æœ¯æ€æ ·è¢«åº”ç”¨äºä¸¤ä¸ªæˆ–è€…æ›´å¤šçš„äººå·¥æ™ºèƒ½æ··åˆçš„ç³»ç»Ÿå‘¢ï¼Ÿ Gaming the Systemç”¨åšå¼ˆè®­ç»ƒæ•´ä¸ªç³»ç»Ÿ Much of Parkesâ€™ work involves game theory. Game theory helps researchers understand what types of rewards will elicit collaboration among otherwise self-interested players, or in this case, rational AIs. Once an AI figures out how to maximize its own reward, what will entice it to act in accordance with another AI?å¸•å‰æ–¯å¾ˆå¤§ä¸€éƒ¨åˆ†å·¥ä½œåŒ…å«åšå¼ˆè®ºã€‚åšå¼ˆè®ºèƒ½å¸®åŠ©ç ”ç©¶è€…ç†è§£å“ªäº›å¥–åŠ±çš„ç±»å‹ä¼šå¼•å‡ºâ€œè‡ªç§çš„â€å±€ä¸­äººçš„åˆä½œè¡Œä¸ºï¼Œåœ¨å½“å‰çš„æƒ…å†µä¸­ï¼Œæ˜¯ç†æ€§çš„äººå·¥æ™ºèƒ½ç³»ç»Ÿã€‚ä¸€æ—¦äººå·¥æ™ºèƒ½ææ¸…æ¥šå¦‚ä½•å»è®©è‡ªèº«çš„å¥–åŠ±æœ€å¤§åŒ–ï¼Œä»€ä¹ˆä¼šå½±å“å…¶ç³»ç»Ÿå’Œå…¶ä»–äººå·¥æ™ºèƒ½ç³»ç»Ÿçš„ååŒå‘¢ï¼Ÿ To answer this question, Parkes turns to an economic theory called mechanism design.ä¸ºäº†è§£ç­”è¿™äº›é—®é¢˜ï¼Œå¸•å‰æ–¯è½¬å‘äº†å¯¹ä¸€ç§å«æœºåˆ¶è®¾è®¡çš„çš„ç»æµå­¦ç†è®ºçš„ç ”ç©¶ã€‚ Mechanism design theory is a Nobel-prize winning theory that allows researchers to determine how a system with multiple parts can achieve an overarching goal. It is a kind of â€œinverse game theory.â€ How can rules of interaction â€“ ways to distribute rewards, for instance â€“ be designed so individual AIs will act in favor of system-wide and societal preferences? Among other things, mechanism design theory has been applied to problems in auctions, e-commerce, regulations, environmental policy, and now, artificial intelligence.æœºåˆ¶è®¾è®¡ç†è®ºæ˜¯ä¸€ä¸ªè·å¾—è¿‡è¯ºå¥–çš„ç†è®ºï¼Œè¿™ä¸ªç†è®ºå…è®¸ç ”ç©¶è€…å»å†³å®šä¸€ä¸ªå¤šéƒ¨åˆ†ç»„æˆçš„ç³»ç»Ÿå»å¦‚ä½•è·å–å®è§‚çš„ç›®æ ‡ã€‚è¿™æ˜¯ä¸€ç§â€œåå‘åšå¼ˆè®ºâ€ã€‚äººå·¥æ™ºèƒ½ç³»ç»Ÿä¹‹é—´çš„äº’åŠ¨è§„åˆ™ â€” åœ¨è¿™é‡Œæ˜¯å‘æ”¾å¥–åŠ±çš„æ–¹æ³•æˆ–è€…é€”å¾„ â€” å¦‚ä½•è¢«è®¾è®¡ç”¨æ¥æ¨åŠ¨ç³»ç»Ÿå±‚é¢æˆ–è€…ç¤¾ä¼šå±‚é¢çš„åå¥½ï¼Ÿåœ¨è¿™äº›é—®é¢˜ä¸­ï¼Œæœºåˆ¶è®¾è®¡ç†è®ºå·²ç»è¢«åº”ç”¨åˆ°å¾ˆå¤šå®é™…çš„é¢†åŸŸä¸­ï¼Œç”µå­å•†åŠ¡ï¼Œæ³•å¾‹æ³•è§„ï¼Œç¯å¢ƒæ”¿ç­–ï¼Œç°åœ¨ï¼Œäººå·¥æ™ºèƒ½ã€‚ The difference between Parkesâ€™ work with AIs and mechanism design theory is that the latter requires some sort of mechanism or manager overseeing the entire system. In the case of an automated car or a drone, the AIs within have to work together to achieve group goals, without a mechanism making final decisions. As the environment changes, the external rewards will change. And as the AIs within the system realize they want to make some sort of change to maximize their rewards, theyâ€™ll have to communicate with each other, shifting the goals for the entire autonomous system.å¸•å‰æ–¯äººå·¥æ™ºèƒ½ç³»ç»Ÿçš„å·¥ä½œå’Œæœºåˆ¶è®¾è®¡ç†è®ºçš„ä¸åŒåœ¨äºåè€…è¦æ±‚æŸç§æœºåˆ¶æˆ–è€…ç®¡ç†è€…æ¥ç›‘ç£æ•´ä¸ªç³»ç»Ÿã€‚è€Œåœ¨è‡ªåŠ¨é©¾é©¶æ±½è½¦æˆ–è€…æ— äººè½¦çš„ä¾‹å­ä¸­ï¼Œå…¶ä¸­åŒ…å«çš„äººå·¥æ™ºèƒ½ç³»ç»Ÿéœ€è¦ä¸€èµ·åä½œåŒºå®Œæˆæ•´ä¸ªå›¢ä½“çš„ç›®æ ‡ï¼Œå¹¶ä¸éœ€è¦ä¸€ä¸ªæœºåˆ¶å»åšæœ€ç»ˆçš„å†³ç­–ã€‚å½“ç¯å¢ƒæ”¹å˜çš„æ—¶å€™ï¼Œå†…éƒ¨çš„å¥–åŠ±ä¹Ÿä¼šæ”¹å˜ã€‚å¹¶ä¸”å½“è¿™äº›äººå·¥æ™ºèƒ½ç³»ç»Ÿæ„è¯†åˆ°ä»–ä»¬éœ€è¦åšä¸€äº›æ”¹å˜ï¼Œä»¥å‡å°‘å…¶å¥–åŠ±ï¼Œä»–ä»¬ä¼šç›¸äº’è¿›è¡Œé€šä¿¡ï¼Œå°†ç›®æ ‡å’Œæ•´ä¸ªè‡ªåŠ¨é©¾é©¶ç³»ç»Ÿåšæ•´åˆåè°ƒã€‚ Parkes summarized his work for FLI, saying, â€œThe work that Iâ€™m doing as part of the FLI grant program is all about aligning incentives so that when autonomous AIs decide how to act, they act in a way thatâ€™s not only good for the AI system, but also good for society more broadly.â€å¸•å‰æ–¯å¯¹FLIæ€»ç»“äº†å…¶å·¥ä½œï¼Œä»–è¯´ï¼Œâ€œæˆ‘æ­£åœ¨åšçš„äº‹æƒ…ï¼Œä½œä¸ºFLIæ•´ä¸ªé¡¹ç›®çš„ä¸€éƒ¨åˆ†ï¼Œå…¶å®å°±æ˜¯åè°ƒæ¿€åŠ±ä»¥ä¾¿äºè‡ªåŠ¨çš„äººå·¥æ™ºèƒ½ç³»ç»Ÿå¯ä»¥å†³å®šå¦‚ä½•å»è¡ŒåŠ¨ï¼Œè€Œä¸”ä¸ä»…ä»…æ˜¯åŸºäºä¸ºäº†è‡ªèº«ç³»ç»Ÿçš„åˆ©ç›Šï¼Œæ›´è¦åŸºäºå¹¿ä¹‰ä¸Šç¤¾ä¼šçš„åˆ©ç›Šã€‚â€ Parkes is also involved with the One Hundred Year Study on Artificial Intelligence, and he explained his â€œresearch with FLI has informed a broader perspective on thinking about the role that AI can play in an urban context in the near future.â€ As he considers the future, he asks, â€œWhat can we see, for example, from the early trajectory of research and development on autonomous vehicles and robots in the home, about where the hard problems will be in regard to the engineering of value-aligned systems?â€å¸•å‰æ–¯åŒæ—¶ä¹Ÿå‚ä¸äº†â€œäººå·¥æ™ºèƒ½ç™¾å¹´ç ”ç©¶â€é¡¹ç›®ï¼Œä»–è¿™æ ·è§£é‡Šè‡ªå·±çš„å·¥ä½œâ€œåœ¨FLIçš„ç ”ç©¶ä¸ºè‡ªå·±æä¾›äº†ä¸€ä¸ªæ›´åŠ å®½å¹¿çš„è§’åº¦ï¼Œä»¥ä¾¿æ€è€ƒåœ¨æœªæ¥çš„åŸå¸‚ç”Ÿæ´»ä¸­äººå·¥æ™ºèƒ½å¯ä»¥æ‰®æ¼”æ€æ ·çš„è§’è‰²ã€‚â€ä»–åŒæ—¶ä¹Ÿå¯¹æœªæ¥æœ‰æ‰€é¡¾è™‘ï¼Œä»–é—®é“ï¼Œâ€œæˆ‘èƒ½å¯ä»¥çœ‹åˆ°ä»€ä¹ˆï¼Œæ¯”å¦‚ï¼Œæ—©æœŸçš„ç ”ç©¶è·¯å¾„å’Œè‡ªåŠ¨é©¾é©¶æ±½è½¦ä»¥åŠå®¶åº­æœºå™¨äººï¼ŒåŒ…æ‹¬åœ¨æœ‰ä»·å€¼å€¾å‘çš„äººå·¥æ™ºèƒ½ç³»ç»Ÿå·¥ç¨‹ä¸­ï¼Œå›°éš¾çš„é—®é¢˜åˆä¼šåœ¨ä»€ä¹ˆåœ°æ–¹å‡ºç°å‘¢ï¼Ÿâ€ "},{"title":"Sorting algorithms","date":"2016-10-08T15:00:00.000Z","url":"/2016/10/08/2016-10-08-Solution-quicksort/","tags":[["Sorting QuickSort BubbleSort","/tags/Sorting-QuickSort-BubbleSort/"]],"categories":[["Algorithm","/categories/Algorithm/"]],"content":"é¢˜ç›®ï¼šè¯·æ‰‹å†™å‡ºä¸¤ç§ä»¥ä¸Šæ’åºç®—æ³•ï¼Œå¹¶åˆ†æä¸åŒæƒ…å†µä¸‹å¤æ‚åº¦çš„å˜åŒ–æƒ…å†µï¼ˆè¯­è¨€ä¸é™ï¼‰ã€‚ æ€è€ƒï¼šç®—æ³•åˆ†æé¢†åŸŸï¼Œæ’åºç®—æ³•åº”è¯¥ç®—æ˜¯æœ€åŸºç¡€çš„ï¼Œå…¥é—¨å°±ä¼šæ¥è§¦åˆ°çš„ç®—æ³•ã€‚ä½†æ˜¯åœ¨è¿™çœ‹ä¼¼ç®€å•çš„æ’åºä¸Šï¼Œå´ä½“ç°äº†ç®—æ³•åˆ†ææœ€ç²¾é«“çš„æ€æƒ³ã€‚åœ¨æ’åºç®—æ³•çš„å†å²å‘å±•è¿‡ç¨‹å½“ä¸­ï¼Œæœ‰æ— æ•°å¤§ç¥å‘æ˜äº†Nå¤šç§æ’åºç®—æ³•ï¼Œä¹Ÿæœ‰ç»™CSçš„å­¦ç”Ÿæä¾›äº†å¤§é‡è®ºæ–‡ç´ æã€‚æˆ‘åœ¨è¿™é‡Œä»…ä»…é€‰æ‹©ä¸€äº›ç®€å•çš„å…¸å‹è¿›è¡Œå®ç°ï¼Œç›®çš„æ˜¯ä¸ºäº†å¸®åŠ©è‡ªå·±è¿›ä¸€æ­¥ç†è§£å…¶ä¸­çš„æ ¸å¿ƒæ€æƒ³ã€‚ æœ€å¸¸è§çš„æ’åºè«è¿‡äºå†’æ³¡ï¼Œå¿«æ’ï¼Œå½’å¹¶äº†ã€‚å…·ä½“çš„å®ç°ä»£ç äº¦æœ‰å‚è€ƒä¸€äº›å‰è¾ˆã€‚æ¬¢è¿å¤§å®¶ä¸€èµ·äº¤æµï¼Œå­¦ä¹ ã€‚ C#æ’åºç®—æ³•å®ç°ï¼š JAVAå®ç°ä¸Šè¿°ä¸‰ç§æ’åº pythonå®ç°ä»¥ä¸Šä¸‰ç§ç®—æ³•"},{"title":"Solution of Equilibrium Index Problem in O(N)","date":"2016-10-07T15:00:00.000Z","url":"/2016/10/07/2016-10-07-Solution-equilibrium-index/","tags":[["Equilibrium Index O(N)","/tags/Equilibrium-Index-O-N/"]],"categories":[["Algorithm","/categories/Algorithm/"]],"content":"In this blog, I gave the solution of Equilibrium Index Problem (O(N)) in Three Languages. The first one is writen in java The second one is writen in python The third one is writen in c#"}]